;;;;
;;;; Created       : 2000 Jan 18 (Tue) 04:24:10 by Harold Carr.
;;;; Last Modified : 2000 Oct 29 (Sun) 21:53:11 by .
;;;;

;made into primitive for speed

;(define instanceof
;  (lambda (obj type)
;    (isInstance (_si 'forName 'java.lang.Class (toString type)) obj)))

;;; End of file.;;;;
;;;; Created       : 2000 Jan 18 (Tue) 04:24:10 by Harold Carr.
;;;; Last Modified : 2001 Mar 26 (Mon) 15:18:30 by Harold Carr.
;;;;

;made into primitives for speed

;(define not
;  (lambda (x) (_if x false true)))

;(define null?
;  (lambda (x) (eq? x null)))

;(define pair?
;  (lambda (exp) (instanceof exp 'lava.lang.types.Pair)))

;(define string->symbol
;  (lambda (x) (_si 'newSymbol 'lavaProfile.F x)))

;(define symbol?
;  (lambda (exp) (instanceof exp 'lava.lang.types.Symbol)))

;;; End of file.;;;;
;;;; Created       : 2000 Jan 18 (Tue) 04:24:10 by Harold Carr.
;;;; Last Modified : 2000 Oct 29 (Sun) 21:55:03 by .
;;;;

;; map made into primitive for speed.

;(define (map f . lists) 
;  (if (null? lists)
;      '() 
;      (if (null? (cdr lists))
;	  (_%mapone f (car lists)) 
;	  (_%mapmany f lists))))
;
;(define _%mapone
;  (lambda (f x)  
;    (if (null? x)
;	'() 
;	(cons (f (car x))
;	      (_%mapone f (cdr x))))))
;
;(define _%mapmany
;  (lambda (f xs)  
;    (if (null? (car xs))
;	'() 
;	(cons (apply f (_%mapone car xs))
;	      (_%mapmany f (_%mapone cdr xs))))))
;

;;; REVISIT

(define for-each map)

;;;; End of file.
;;;;
;;;; Created       : 2000 Jan 18 (Tue) 04:24:10 by Harold Carr.
;;;; Last Modified : 2000 Oct 29 (Sun) 21:54:49 by .
;;;;

;;; Safe car and cdr.

(define _%scar (lambda (x) (if (null? x) '() (car x))))
(define _%scdr (lambda (x) (if (null? x) '() (cdr x))))

;; REVISIT  handling of ==>
;; REVISIT collapse cadr s

(define-syntax cond 
  (lambda args  
    (if (null? args) 
	false 
	(if (equal? (_%scar (_%scar args)) 'else) 
	    (cons 'begin (_%scdr (_%scar args))) 
	    (if (equal? (_%scar (_%scdr (_%scar args))) '=>) 
		(list '(lambda (x e c) (_if x (e x) (c))) 
		      (_%scar (_%scar args)) 
		      (_%scar (_%scdr (_%scdr (_%scar args)))) 
		      (cons 'lambda (list () (cons 'cond (_%scdr args))))) 
		(if (null? (_%scdr (_%scar args))) 
		    (list '(lambda (x c) (_if x x (c))) 
			  (_%scar (_%scar args)) 
			  (cons 'lambda (list () (cons 'cond (_%scdr args))))) 
		    (list '_if (_%scar (_%scar args)) 
			  (cons 'begin (_%scdr (_%scar args))) 
			  (cons 'cond (_%scdr args)))))))))

(define-syntax or
  (lambda args
    (if (null? args)
        false
        (cons 'cond (map list args)))))

(define-syntax and
  (lambda args
    (cond ((null? args) true)
	  ((null? (cdr args)) (car args))
	  (else (list '_if (car args) (cons 'and (cdr args)) false)))))

;;; End of file.

;;;;
;;;; Created       : 2000 Jan 18 (Tue) 04:24:10 by Harold Carr.
;;;; Last Modified : 2001 Mar 07 (Wed) 14:54:17 by Harold Carr.
;;;;

(define-syntax quasiquote
  (lambda (x)
    (_%expand-quasiquote x 0)))

(define _%expand-quasiquote
  (lambda (exp nesting)
    (cond
     ((not (pair? exp))
      ;;(_println 1)
      (if (_%constant? exp) 
	  (begin 
	    ;;(_println 1.1)
	    exp)
	  (begin 
	    ;;(_println 1.2)
	    (_list 'quote exp))))
     ((and (eq? (car exp) 'unquote) 
	   (equal? (length exp) 2))
      ;;(_println 2)
      (if (equal? nesting 0)
	  (begin 
	    ;;(_println 2.1)
	    (car (cdr exp)))
	  (begin
	    ;;(_println 2.2)
	    (_%combine-skeletons ''unquote
			       (_%expand-quasiquote (cdr exp) (- nesting 1))
			       exp))))
     ((and (eq? (car exp) 'quasiquote)
	   (equal? (length exp) 2))
      ;;(_println 3)
      (_%combine-skeletons ''quasiquote
			 (_%expand-quasiquote (cdr exp) (+ nesting 1))
			 exp))
     ((and (pair? (car exp))
	   (eq? (car (car exp)) 'unquote-splicing)
	   (equal? (length (car exp)) 2))
      ;;(_println 4)
      (if (equal? nesting 0)
	  (begin
	    ;;(_println 4.1)
	    (_list 'append (car (cdr (car exp)))
		  (_%expand-quasiquote (cdr exp) nesting)))
	  (begin
	    ;;(_println 4.2)
	    (_%combine-skeletons (_%expand-quasiquote (car exp) (- nesting 1))
			       (_%expand-quasiquote (cdr exp) nesting)
			       exp))))
     (else 
      ;;(_println 5)
      (_%combine-skeletons (_%expand-quasiquote (car exp) nesting)
			 (_%expand-quasiquote (cdr exp) nesting)
			 exp)))))

(define _%constant?
  (lambda (exp)
    (if (pair? exp)
	(eq? (car exp) 'quote)
	(not (symbol? exp)))))

(define _%combine-skeletons
  (lambda (left right exp)
    (cond
     ((and (_%constant? left) (_%constant? right))
      ;; (_println'cb1)
      (if (and (equal? (eval left ) (car exp))
	       (equal? (eval right) (cdr exp)))
	  (begin 
	    ;;(_println 'cb1.1)
	    (_list 'quote exp))
	  (begin 
	    ;;(_println 'cb1.2) 
	    (_list 'quote (cons (eval left )
			       (eval right))))))
     ((null? right)
      ;;(_println 'cb2)
      (_list '_list left))
     ((and (pair? right) (eq? (car right) '_list))
      ;;(_println 'cb3)
      (cons '_list (cons left (cdr right))))
     (else 
      ;;(_println 'cb4)
      (_list 'cons left right)))))

;;; End of file.;;;;
;;;; Created       : 2000 Jan 18 (Tue) 04:24:10 by Harold Carr.
;;;; Last Modified : 2000 Jan 21 (Fri) 20:42:59 by Harold Carr.
;;;;

;; REVISIT - add named-let

(define-syntax let
  (lambda (bindings . body)
    `((lambda ,(map car bindings) . ,body) . ,(map cadr bindings))))

(define-syntax let*
  (lambda (bindings . body)
    (if (null? bindings) `((lambda () . ,body))
        `(let (,(car bindings))
           (let* ,(cdr bindings) . ,body)))))

(define-syntax letrec
  (lambda (bindings . body)
    (let ((vars (map car  bindings))
	  (vals (map cadr bindings)))
      `(let ,(map (lambda (var) `(,var false)) vars)
	 ,@(map (lambda (var val) `(set! ,var ,val)) vars vals)
	 . ,body))))

;;; End of file.;;;;
;;;; Created       : 2000 Jan 18 (Tue) 05:58:33 by Harold Carr.
;;;; Last Modified : 2000 Oct 29 (Sun) 21:53:45 by .
;;;;

(define _%do-case 
  (lambda (case)
    (cond ((not (pair? case)) (error "bad syntax in case" case))
	  ((eq? (first case) 'else) case)
	  (else `((member __exp__ ',(first case)) . ,(rest case))))))

(define-syntax case
  (lambda (exp . cases)
    `(let ((__exp__ ,exp)) (cond . ,(map _%do-case cases)))))

;;; End of file.
;;;;
;;;; Created       : 2000 Jan 18 (Tue) 05:58:33 by Harold Carr.
;;;; Last Modified : 2000 Jan 21 (Fri) 20:43:10 by Harold Carr.
;;;;

(define-syntax do
  (lambda (bindings test-and-result . body)
    (let ((variables (map first bindings))
          (inits (map second bindings))
          (steps (map (lambda (clause)
                        (if (null? (cddr clause))
                            (first clause)
                            (third clause)))
                      bindings))
          (test (first test-and-result))
          (result (rest test-and-result)))
      `(letrec ((__loop__
                 (lambda ,variables
                   (if ,test
                       (begin . ,result)
                       (begin
                         ,@body
                         (__loop__ . ,steps))))))
         (__loop__ . ,inits)))))

;;; End of file.
;;;;
;;;; Created       : 2000 Jan 18 (Tue) 04:24:10 by Harold Carr.
;;;; Last Modified : 2000 Feb 21 (Mon) 02:14:06 by Harold Carr.
;;;;

(define (memq this that)
  (cond ((null? that) false)
	((eq? this (car that)) that)
	(else (member this (cdr that)))))

(define (member this that)
  (cond ((null? that) false)
	((equal? this (car that)) that)
	(else (member this (cdr that)))))

;;; End of file.

;;;;
;;;; Created       : 2000 Jan 18 (Tue) 04:24:10 by Harold Carr.
;;;; Last Modified : 2000 Oct 29 (Sun) 21:53:38 by .
;;;;

;;; REVISIT - gensym let vars

(define-syntax try
  (lambda exprs-catch-finally
    (let ((tryExprs     (_%getTryExpressions     exprs-catch-finally))
	  (catchClauses (_%getCatchClauses       exprs-catch-finally))
	  (finallyExprs (_%getFinallyExpressions exprs-catch-finally)))
      `(_%try
	(lambda () ,@tryExprs)
	(lambda (t)
	  (let ((g2 (if (instanceof t 'lava.lang.exceptions.LavaException)
			(getThrowable t)
			t)))
	    (cond ,@catchClauses
		  (else (throw t)))))
	(lambda () ,@finallyExprs)))))

(define (_%getTryExpressions exprs)
  (_%appendResults (lambda (x) (if (or (not (pair? x)) ; ref ok
				       (and (not (eq? (car x) 'catch))
					    (not (eq? (car x) 'finally))))
				   ;;  extra list level for appendResults
				   `(,x)
				   '()))
		   exprs))

(define (_%getCatchClauses catch-finally)
  (_%appendResults (lambda (x) (if (and (pair? x)
					(eq? (car x) 'catch))
				   `(((instanceof g2 ',(car (cadr x)))
				      (let ((,(cadr (cadr x)) g2)) ,@(cddr x))))
				   '()))
		   catch-finally))

(define (_%getFinallyExpressions catch-finally)
  (_%appendResults (lambda (x) (if (and (pair? x)
					(eq? (car x) 'finally))
				   (cdr x)
				   '()))
		   catch-finally))

;; removes empty lists

(define (_%appendResults proc lst)
  (apply append (map proc lst)))

;;; End of file.

;;;;
;;;; Created       : 2000 Jan 24 (Mon) 20:42:21 by Harold Carr.
;;;; Last Modified : 2001 Mar 10 (Sat) 19:52:20 by Harold Carr.
;;;;

(define-syntax synchronized
  (lambda (lock . body)
    `(_%synchronized ,lock (lambda () ,@body))))

(define-syntax import
  (lambda (classPathAndName)
    `(_%import ',classPathAndName)))

(define-syntax package
  (lambda (packagePathAndName className)
    `(_%package ',packagePathAndName ',className)))

;;; End of file.;;;;
;;;; Created       : 1999 Feb 10 (Wed) 21:35:48 by Harold Carr.
;;;; Last Modified : 2001 Mar 26 (Mon) 15:36:55 by Harold Carr.
;;;;

;;;
;;; Very simple require/provide.
;;;

;; REVISIT - make recursive calls to provide report correct
;; file not found error.

;;; This is the most interesting part.
;;; It dynamically figures out where the */lib directory is located.

(define _%getLibPath
  (lambda ()
    (let* ((LavaPath
	    ;; getResource returns either "file:<path>" or "jar:file:<path>"
	    ;; getFile returns either "<path>" or "file:<path>"
	    (getFile (getResource (_si 'forName 'java.lang.Class "lavaProfile.Lava")
				  "Lava.class")))
	   (i -1))
      (cond ((not (equal? (set! i (indexOf LavaPath "lava/.classes")) -1))
	     (string-append (substring LavaPath 0 i) "lava/lib"))
	    ((not (equal? (set! i (indexOf LavaPath "lava/jars/lava.jar!")) -1))
	     ;; 6 skips the "file:"
	     ;; i removes the !.
	     (string-append (substring LavaPath 6 i) "lava/lib"))
	    (else
	     ;; REVISIT
	     (_println (list "Cannot initialize require path." LavaPath)))))))

(let ((load-path    (list (_%getLibPath)))
      (provided '()))

  (define load-path
    (lambda () load-path))

  (define (provided) provided)

  (define reset-provided
    (lambda () (set! provided '())))

  (define push-on-load-path
    (lambda (name)
      (set! load-path 
	    (if (pair? name)
		(append (map toString name) load-path)
		;; Assume it is a string or symbol.
		(cons (toString name) load-path)))))

  (define append-to-load-path
    (lambda (name)
      (set! load-path 
	    (append load-path 
		    (if (pair? name)
			(map toString name)
			(list (toString name)))))))

  (define provided?
    (lambda (name)
      (_if (member (toString name) provided) #t #f)))

  (define (provide name)
    (let ((sname (toString name)))
      (if (not (provided? name))
	  (set! provided (cons sname provided)))
      name))

  (define (require name)
    (_%require (toString name) load-path))

  (define load-library
    (lambda (name)
      (_%load-library (toString name) load-path)))

  (define _%require
    (lambda (name loadPath)
      (if (not (provided? name))
	  (_%load-library name loadPath))))

  (define _%load-library
    (lambda (name loadPath)
      (call/cc
       (lambda (return)
	 (for-each
	  (lambda (path)
	    (let ((pathAndName (string-append path "/" name ".lva")))
	      (try 
	       (load pathAndName)
	       (return pathAndName)
	       (catch (java.io.FileNotFoundException e)
		      'ignore))))
	  loadPath)
	 (throw (new 'java.io.FileNotFoundException name))))))

)

(_comment
(load "RequireProvide.lva")
provided
(require "foo")
(provided? 'foo)
(require 'import)
)

;;; End of file.
;;;;
;;;; Created       : 2000 Jan 23 (Sun) 17:28:32 by Harold Carr.
;;;; Last Modified : 2000 Jan 23 (Sun) 19:20:55 by Harold Carr.
;;;;

;; This file is a convenient place to put definitions
;; and then exercise those definitions from TestTop.testTop
;; under control of a Java debug stepper.

;; Intentionally blank.

;;; End of file.
;;;;
;;;; Created       : 1998 Dec 13 (Sun) 09:18:12 by Harold Carr.
;;;; Last Modified : 2001 Mar 08 (Thu) 21:01:07 by Harold Carr.
;;;;
;;;; Provides import
;;;;

; Given a Java class:
;
;     *****
;
; then
;
;     (import '*****)
;
; results in the following procedure definitions:
;
;     *****
;
; Alternatively, rather than define all public constructors, methods
; fields, one can specify the subset to be defined:
;
;     (import '***** '*****)
;

(define-syntax _%setq
  (lambda (var val)
    `(let ((_lazy_hygenie_ ,val))
       (set! ,var _lazy_hygenie_)
       _lazy_hygenie_)))

;;;;
;;;; First we define a few by hand to be used by "import" and friends.
;;;;

(define _%java_lang_Class_forName 
  (lambda (className)
    (if (symbol? className) (set! className (toString className)))  
    (_si 'forName 'java.lang.Class className)))

(define _%java_lang_reflect_Modifier_isPublic 
  (lambda (int)
    (_si 'isPublic 'java.lang.reflect.Modifier int)))

(define _%java_lang_reflect_Modifier_isStatic
  (lambda (int)
    (_si 'isStatic 'java.lang.reflect.Modifier int)))

(define _%java_lang_reflect_Array_get
  (lambda (o i)
    (_si 'get 'java.lang.reflect.Array o i)))

(define _%java_lang_reflect_Array_getLength 
  (lambda (o)
    (_si 'getLength 'java.lang.reflect.Array o)))

;;;
;;; _%isPublic? _%isStatic?
;;;

(define _%isPublic?
  (lambda (x)
    (_%java_lang_reflect_Modifier_isPublic (getModifiers x))))

(define _%isStatic?
  (lambda (x)
    (_%java_lang_reflect_Modifier_isStatic (getModifiers x))))

;;;
;;; _%isMemberOfArray
;;;
;;; false if not present.  Otherwise the first element which passes the test.
;;;

(define _%isMemberOfArray
  (lambda (test array)
    (call/cc
     (lambda (return)
       (do ((len (_%java_lang_reflect_Array_getLength array))
	    (i 0 (+ i 1)))
	   ((>= i len) (return false))
	 (let ((el (_%java_lang_reflect_Array_get array i)))
	   (if (test el)
	       (return el))))))))

;;;
;;; _%mapJavaArray
;;;

(define _%mapJavaArray 
  (lambda (proc array)
    (let ((result '(dummy)))
      (do ((len (_%java_lang_reflect_Array_getLength array))
	   (rptr result
		 (begin
		   (setCdr rptr
			   (cons (proc (_%java_lang_reflect_Array_get array i))
				 '()))
		   (cdr rptr)))
	   (i 0 (+ i 1)))
	  ((>= i len) (cdr result))))))

;;;
;;; For defining the procedures.  Also for debugging.
;;;

(define *_%evalDefineCMF* 'eval)
(define _%evalDefineCMFWrite (lambda (form) (_println form) form))
(define _%evalDefineCMFEval  (lambda (form) (eval form)))

(define _%evalDefineCMF
  (lambda (form)
    (case *_%evalDefineCMF*
      ((write    ) (_%evalDefineCMFWrite form))
      ((eval     ) (_%evalDefineCMFEval  form))
      ((writeEval) (_%evalDefineCMFEval  (_%evalDefineCMFWrite form)))
      ((none     ) 'none)
      (else (error (string-append "_%evalDefineCMF - unknown: "
				  (toString form)))))))

; Uncomment for debug.
(set! *_%evalDefineCMF* 'writeEval)
;(set! *_%evalDefineCMF* 'write)

;;;
;;; Always useful.
;;;

(define _%makeSymOrStr
  (lambda (symOrStr . args)
    (let ((result (apply string-append
			 (map (lambda (x)
				(if (symbol? x)
				    (toString x)
				    x))
			      args))))
      (if (eq? symOrStr 'symbol)
	  (string->symbol result)
	  result))))

;;;
;;; Determines whether procedures are defined as
;;;
;;;     (define (java.lang.Float.valueOf . args) ...)
;;;
;;; or
;;;
;;;     (define (valueOf . args) ...)
;;;
;;; The first is useful when not using a package system.
;;; The second is the default and assume you are already in
;;; the correct package.
;;;

(define _%fullName? false)

;;;
;;; Useful for browsing the methods of a class.
;;;

(define _%showVirtual? false)

;;;
;;; import
;;;
;;; The main procedure.
;;;

(define _%importAux
  (lambda (className . methodOrFieldNames)
    (let* ((class
	    (_%java_lang_Class_forName (_%makeSymOrStr 'string className)))
	   (constructors (getConstructors    class))
	   (methods      (getDeclaredMethods class))
	   (fields       (getDeclaredFields  class)))
      (if (null? methodOrFieldNames)
	  (_%defineAllCMF className class constructors methods fields)
	  (for-each
	   (lambda (methodOrFieldName)
	     (_%defineCMF
	      className
	      (_%makeSymOrStr 'symbol methodOrFieldName)
	      class constructors methods fields))
	   methodOrFieldNames)))
    true))

;; Define an individual constructor, method or field.

(define _%defineCMF
  (lambda (className methodOrFieldName class constructors methods fields)
    (if (eq? methodOrFieldName 'constructor)
	(_%defineC className class constructors)
	(_%defineMF className methodOrFieldName class methods fields))))

;; Define an individual constructor.

(define _%defineC
  (lambda (className class constructors)
    "Use new"))
(_comment
    (if (and (not (equal? 0
			  (_%java_lang_reflect_Array_getLength constructors)))
	     (not (equal? 0 
			  (length (apply 
				   append
				   (_%mapJavaArray
				    (lambda (x)
				      (if (_%isPublic? x) '(true) '()))
				    constructors))))))
	(_%evalDefineCMF
	 `(define (,className . args) (apply new (cons ',className args))))
	(error 
	 (string-append "No constructor for class: " (toString className))))
)


;; Define an individual method or field.

(define _%defineMF
  (lambda (className methodOrFieldName class methods fields)
    (let* ((nameString (_%makeSymOrStr 'string methodOrFieldName))
	   (test       (lambda (el) (equal? (getName el) nameString)))
	   (el         '()))
      (cond ((_%setq el (_%isMemberOfArray test methods))
	     (if (_%isPublic? el) 
		 (_%defineM className methodOrFieldName class el)))
	    ((_%setq el (_%isMemberOfArray test fields))
	     (if (_%isPublic? el) 
		 (_%defineF className methodOrFieldName class el)))
	    (else
	     (error (string-append "Unknown method or field: "
				   (toString className)
				   " "
				   (toString methodOrFieldName))))))))

;; Define an individual method.

(define _%defineM
  (lambda (className methodName class method)
    (set! methodName (if _%fullName? 
			 (_%makeSymOrStr 'symbol  className "." methodName)
			 methodName))
    ;; Only static methods since virtual are picked up automatically.
    (if (_%isStatic? method)
	(_%evalDefineCMF
	 ;; REVISIT - no need to use apply? - maybe to get value of methodName
	 `(define (,methodName . args)
	    (apply _si (cons ',methodName (cons ',className args)))))
	(if _%showVirtual?
	    (_%evalDefineCMF methodName)))))

;; Define an individual field.

(define _%defineF 
  (lambda (className fieldName class field)
    (let* ((isStatic (_%isStatic? field))
	   (name     (if (and _%fullName? isStatic)
			 (_%makeSymOrStr 'symbol className "." fieldName)
			 fieldName))
	   (name!    (_%makeSymOrStr 'symbol name "!"))
	   (andArg   (if isStatic `(,name)  `(,name  o)))
	   (andArg!  (if isStatic `(,name!) `(,name! o)))
	   (andVal   (append andArg  '(v)))
	   (andVal!  (append andArg! '(v))))
      (_%evalDefineCMF
       `(define ,andArg
	  ,(if isStatic
	       `(_sf ',fieldName ',className)
	       `(_f  ',fieldName o))))
      (_%evalDefineCMF
       `(define ,andVal!
	  ,(if isStatic
	       `(_sf ',fieldName ',className v)
	       `(_f  ',fieldName o           v)))))))

; Define procedures for all public constructors, methods and fields.

(define _%defineAllCMF
  (lambda (className class constructors methods fields)
    (let* ((methodNames (_%mapJavaArray (lambda (x) (getName x)) methods))
	   (fieldNames  (_%mapJavaArray (lambda (x) (getName x)) fields))
	   (methodAndFieldNames (append methodNames fieldNames))
	   (importArgs
	    (cons className
		  (if (> (_%java_lang_reflect_Array_getLength constructors) 0)
		      (cons 'constructor methodAndFieldNames)
		      methodAndFieldNames))))
      (apply _%importAux importArgs))))
      
(_comment

(load "import.lva")
;(set! *_%evalDefineCMF* 'write)
;(set! *_%evalDefineCMF* 'writeEval)
(_%import 'java.lang.Float)
(import 'java.lang.Float 'constructor)
(java.lang.Float "34")
(java.lang.Float.MAX_VALUE)
(java.lang.Float.MAX_VALUE! (java.lang.Float 3.4028235E38))
(_%importAux 'java.util.Vector)
(_%importAux 'java.util.Hashtable)
(_%importAux 'java.lang.System 'out)
(import 'java.lang.System 'constructor)
(import 'java.lang.System 'bar)
(import 'java.util.Vector 'constructor 'addElement 'contains 'toString)
(define v (java.util.Vector))
(isEmpty v)
(define o (java.lang.System.out))
(addElement v o)
(isEmpty v)
(contains v o)
(toString v)
)


;;; End of file.