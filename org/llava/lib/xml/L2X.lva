;;;; Copyright (c) 1997 - 2004 Harold Carr
;;;;
;;;; This work is licensed under the Creative Commons Attribution License.
;;;; To view a copy of this license, visit 
;;;;   http://creativecommons.org/licenses/by/2.0/
;;;; or send a letter to
;;;;   Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA
;;;;---------------------------------------------------------------------------

;;;;
;;;; Created       : 2001 Mar 06 (Tue) 15:09:50 by Harold Carr.
;;;; Last Modified : 2004 Sep 21 (Tue) 12:09:25 by Harold Carr.
;;;;

(package org.llava.lib.xml.L2X)

(import org.llava.lib.cl.Control) ; dotimes
(import org.llava.lib.io.FileWalker)

;(import org.llava.lib.Control) 

(-package- 
 (description
  "Transform a \"lispy\" version of XML (called \"lxml\") into angle bracket
   xml."))

;;;;
;;;; --------------------------------------------------
;;;; LXML -> XML
;;;;

(-doc-
 (name "l-&gt;x"))

;;;
;;; The main interactive routine.
;;; Given an LXML expression, prints it out as XML.
;;;

(define l->x
  (lambda (lxml)
    (file-walker-with-indent lxml 0)))

;; Make newline and indent false by default so "mailto" attributes do not
;; end up with space in them.  Turn to true for development.

(file-walker-newline? false)
(file-walker-indent? false)
(define l->x-indent-amount 2) ; if above is true

(define l->x-dispatch
  (lambda (sexpr indent)
    (if (not (pair? sexpr))
	(l->x-printText sexpr)
	(case (car sexpr)
	  ((?)   (l->x-printProcessingInstruction sexpr indent))
	  ((!)   (-println (string-append "ignoring: " (toString sexpr))))
	  ((!DOCTYPE)
                 (l->x-printDOCTYPE sexpr indent))
	  ((!CDATA)
                 (l->x-printCDATA sexpr indent))
	  ((!--) (l->x-printComment sexpr indent))
	  ((&&)  (l->x-printEntity sexpr indent))
	  (else  (l->x-printElement sexpr indent))))))

(set-file-walker-dispatcher! l->x-dispatch)
(set-file-walker-print-header! (lambda (a b c) null))
(set-file-walker-print-footer! (lambda (a b c) null))

(define l->x-printElement
  (lambda (element indent)
    (let* ((hasAttributes (and (not (null? (cdr element)))
			       (pair? (cdr element))
			       (pair? (cadr element))
			       (equals '@ (car (cadr element)))))
	   (name (car element))
	   (attributes (if hasAttributes (cdr (cadr element)) null))
	   (body (if hasAttributes (cddr element) (cdr element))))
      (file-walker-newline)
      (file-walker-indent indent)
      (file-walker-print "<")
      (file-walker-print name)
      (l->x-printAttributes attributes)
      (cond ((null? body)
	     (file-walker-print "/>"))
	    (else
	     (file-walker-print ">")
	     (file-walker-with-indent body (+ indent l->x-indent-amount))
	     (file-walker-print "</")
	     (file-walker-print name)
	     (file-walker-print ">"))))))

(define l->x-printEntity
  (lambda (entity indent)
    (file-walker-print " &")
    (file-walker-print (cadr entity))
    (file-walker-print "; ")))

(define l->x-printProcessingInstruction
  (lambda (pi indent)
    ;; XML declaration must be on first line.
    (if (not (equals 'xml (cadr pi)))
	(file-walker-newline))
    (file-walker-indent indent)
    (file-walker-print "<?")
    (file-walker-print (cadr pi))
    (l->x-printAttributes (cddr pi))
    (file-walker-print "?>")))

(define l->x-printAttributes
  (lambda (attributes)
    (do ((atts attributes (cdr atts)))
	((null? atts))
      (file-walker-print " ")
      (file-walker-print (caar atts))
      (file-walker-print "=")
      (file-walker-print "\"")
      (file-walker-print (car (cdar atts)))
      (file-walker-print "\""))))

(define l->x-printText 
  (lambda (text)
    (file-walker-print text)))

(define l->x-printComment
  (lambda (comment indent)
    (file-walker-newline)
    (file-walker-indent indent)
    (file-walker-print "<!-- ")
    (for-each file-walker-print (cdr comment))
    (file-walker-print " -->")))

(define l->x-printDOCTYPE
  (lambda (doctype indent)
    (file-walker-newline)
    (file-walker-indent indent)
    (file-walker-print "<!DOCTYPE")
    (do ((d (cdr doctype)            (cdr d))
	 (s '(false false true true) (cdr s)))
	((null? d))
      (file-walker-print " ")
      (if (car s) (file-walker-print "\""))
      (file-walker-print (car d))
      (if (car s) (file-walker-print "\"")))
    (file-walker-print ">")))

(define l->x-printCDATA
  (lambda (cdata indent)
    (file-walker-newline)
    (file-walker-indent indent)
    (file-walker-print "<![CDATA[")
    (file-walker-print (cadr cdata))
    (file-walker-print "]]>")))

;;;
;;; Strings, Streams and files.
;;;

(-doc-
 (name "l-&gt;x-string"))

(define l->x-string
  (lambda (lxml)
    (file-walker-string lxml)))

(-doc-
 (name "l-&gt;x-files"))

(define l->x-files
  (lambda (inFileName outFileName)
    (file-walker-files inFileName outFileName)))

;;;;
;;;; --------------------------------------------------
;;;; XML -> LXML
;;;;

;;; Based on _Java and XML_, Chapter 8, pp 210-211.

(define x->l
  (lambda (uri . out)
    (apply x->l-aux `(DOM LXML ,uri ,@out))))

(define x->l-aux
  (lambda (builderType outputterType uri . out)
    (set! out (if (null? out) 
		  (-sf 'out 'java.lang.System)
		  (x->l-normalize-output-type (car out))))
    (let* ((builder (case builderType
		      ;; p 210.
		      ((SAX) (new 'org.jdom.input.SAXBuilder false))
		      ;; p 211.
		      ((DOM) (new 'org.jdom.input.DOMBuilder
				  "org.jdom.adapters.XercesDOMAdapter"))
		      (else  (error (string-append "unknown: " builderType)))))
	   ;; p 211.
	   (doc (build builder (new 'java.io.File uri))))
      (x->l-printDocument outputterType doc out))))

;; p 223.
(define x->l-printDocument
  (lambda (outputterType doc out)
    (let ((fmt (case outputterType
		 ;; p 223.
		 ((XML)  (new 'org.jdom.output.XMLOutputter))
		 ;; HC extension.
		 ((LXML) (new 'org.jdom.output.LXMLOutputter)))))
      (setSuppressDeclaration fmt false)
      (setOmitEncoding fmt false)
      (setNewlines fmt false)
      (setPadText fmt true)
      (setTrimText fmt false)
      (setExpandEmptyElements fmt true) ;; This one is necessary for LXML
      (output fmt doc out))))

(define x->l-normalize-output-type
  (lambda (out)
    (cond ((equal? (getName (getClass out)) "java.lang.String")
	   (new 'java.io.PrintStream
		(new 'java.io.FileOutputStream out)))
	  (else
	   ;; Assume it is already what is needed.
	   out))))

;;;;
;;;; --------------------------------------------------
;;;; Test.
;;;;

(define (demoRoot tail)
  (string-append (userHome)
		 "/.sync/.lsync/llava/lib/xml/"
		 tail))

(-comment-

(load "L2X.lva")

(dprint? true)
(l->x-string '((? xml (version "1.0") (encoding "UTF-8"))))
(file-walker-out)
;; compare with "./junk.xslt"
(file-walker-newline? true)
(file-walker-indent? true)
(l->x-files "./example.lxsl" "/tmp/junk.xslt")
(l->x-files (demoRoot "xsltBook/me/03Example/bookings.lxml")
	    "/tmp/bookings.xml")
(l->x-files (string-append (userHome) "/.sync/.ksync/rpt/carrEstimates.lxml")
	    "/tmp/carrEstimates.xml")

(x->l (demoRoot "test.xml"))
(x->l-aux 'DOM 'LXML (demoRoot "test.xml"))
;; Must be connected to specs.
(x->l (demoRoot "specs/REC-xml-20001006.xml"))
(x->l "/export/home/carr/InteropTest.wsdl")

)


;;; End of file.
