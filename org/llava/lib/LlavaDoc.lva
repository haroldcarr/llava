;;;; Copyright (c) 1997 - 2004 Harold Carr
;;;;
;;;; This work is licensed under the Creative Commons Attribution License.
;;;; To view a copy of this license, visit 
;;;;   http://creativecommons.org/licenses/by/2.0/
;;;; or send a letter to
;;;;   Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA
;;;;---------------------------------------------------------------------------

;;;;
;;;; Created       : 2004 Sep 03 (Fri) 18:32:41 by Harold Carr.
;;;; Last Modified : 2005 Feb 16 (Wed) 14:47:30 by Harold Carr.
;;;;

(package org.llava.lib.LlavaDoc)

(import org.llava.lib.Files)
(import org.llava.lib.io.FileWalker)
(import org.llava.lib.scm.Lists)

;;;;
;;;; TODO
;;;;
;;;; Replace s+ idiom with FileWalker indent print.
;;;; Make file-walker-dispatcher and friends safe for concurrency.
;;;; Make file-walker-files work without output file.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;; Variables.
;;;;

(define *current-doc-package* 'nothing)
(define *llava-suffix* ".lva")
(define *doc-suffix* ".xml")
(define *tmp-contains-llava-doc?-file* "/tmp/junk-contains-llava-doc")
(define *found-llava-doc-true* "TRUE")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;; First you parse the you format.
;;;;

(define _%-doc-
  (lambda (doc)
    (file-walker-newline)
    (file-walker-print
     (format-entry
      (parse-name doc)
      (parse-category doc)
      (parse-location doc)
      (parse-params doc)
      (parse-result doc)
      (parse-throws doc)
      (parse-description doc)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;; Walking directories, looking for files with -doc- documentation.
;;;;

(-doc-
 (name llava-doc)
 (param source-dir)
 (param destination-dir)
 (description "..."))

(define llava-doc
  (lambda (source-root destination-root)
    (for-each-dir
     (lambda (x) 
       (cond ((and (isFile x)
		   (endsWith (toString x) *llava-suffix*)
		   (contains-llava-doc? x))
	      (write-llava-doc x destination-root)
	      false)))
     source-root)))

(define write-llava-doc
  (lambda (source-file destination-root)
    (let* ((destination-dir (s+ destination-root "/" (getParent source-file)))
	   (filename-minus-suffix (substring (getName source-file)
					     0 (indexOf (getName source-file)
							*llava-suffix*)))
	   (destination-dir-and-filename 
	    (s+ destination-dir "/" filename-minus-suffix *doc-suffix*)))
      (cond ((exists-or-create destination-dir)
	     (extract-doc-files (toString source-file)
				destination-dir-and-filename)
	     (-println (s+ "Wrote: " destination-dir-and-filename)))
	    (else
	     (error (s+ "Cannot create: " destination-dir)))))))

(define exists-or-create
  (lambda (dir-name)
    (let ((dir (new 'java.io.File dir-name)))
      (cond ((exists dir))
	    (else (mkdirs dir))))))

;;;
;;; REVISIT - I wrote this with call/cc with the continuation passed
;;; to the dispatcher but got
;;; llava-> (-jbt)
;;; java.lang.Exception: ContinuationException
;;;	at org.llava.lang.exceptions.LlavaException.<init>(LlavaException.java:41)
;;;	at org.llava.impl.runtime.procedure.primitive.llava.PrimCallCC$ContinuationException.<init>(PrimCallCC.java:83)
;;;	at org.llava.impl.runtime.procedure.primitive.llava.PrimCallCC$Continuation.apply(PrimCallCC.java:69)
;;;
;;; The broken call/cc version is in RCS.
;;;

(define contains-llava-doc?
  (lambda (file)
    ;(-println `(contains-llava-doc? ,file))
    (let ((save-file-walker-dispatcher   (get-file-walker-dispatcher)))
      (try
       (begin
	 (set-file-walker-dispatcher! contains-llava-doc?-dispatch)
	 (file-walker-files (toString file) *tmp-contains-llava-doc?-file*)
	 false)
       (catch (java.lang.Exception e)
	 (if (eq? (getMessage e) *found-llava-doc-true*)
	     true
	     false))
       (finally
	(set-file-walker-dispatcher!   save-file-walker-dispatcher))))))
       
(define contains-llava-doc?-dispatch
  (lambda (sexpr indent)
    (if (and (pair? sexpr)
	     (eq? (car sexpr) '-doc-))
	(throw (new 'java.lang.Exception *found-llava-doc-true*))
	null)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;; Extracting and writing results to a file.
;;;;

(define extract-doc-files 
  (lambda (inFileName outFileName)
    (let ((save-file-walker-dispatcher   (get-file-walker-dispatcher))
	  (save-file-walker-print-header (get-file-walker-print-header))
	  (save-file-walker-print-footer (get-file-walker-print-footer)))
      (try
       (begin
	 (set-file-walker-dispatcher!   extract-doc-dispatch)
	 (set-file-walker-print-header! extract-doc-print-header)
	 (set-file-walker-print-footer! extract-doc-print-footer)
	 (file-walker-files inFileName outFileName))
       (finally
	 (set-file-walker-dispatcher!   save-file-walker-dispatcher)
	 (set-file-walker-print-header! save-file-walker-print-header)
	 (set-file-walker-print-footer! save-file-walker-print-footer))))))

;; convenience for testing
(define extract-doc
  (lambda (forms)
    (set-file-walker-dispatcher!   extract-doc-dispatch)
    (set-file-walker-print-header! extract-doc-print-header)
    (set-file-walker-print-footer! extract-doc-print-footer)
    (file-walker-with-indent forms 0)))

(define extract-doc-dispatch
  (lambda (sexpr indent)
    (cond ((pair? sexpr)
	   (case (car sexpr)
	     ((package) (set! *current-doc-package* (cadr sexpr)))
	     ((-doc-)   (_%-doc- (cdr sexpr)))
	     (else      null))))))

(define extract-doc-print-header
  (lambda (out inFileName outFileName)
    (println out "<!--")
    (print out " Extracted on ")
    (println out (toString (new 'java.util.Date)))
    (print out " Extracted from ")
    (println out inFileName)
    (print out " Extracted to   ")
    (println out outFileName)
    (println out "-->")))

(define extract-doc-print-footer
  (lambda (out inFileName outFileName)
    (println out)
    (println out "<!-- End of file. -->")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;;;
;;;; format to DocBook
;;;;

(define format-entry
  (lambda (name category location params result throws description)
    ;(-println (list name category location params result throws description))
    (s+
     (format-refentry-begin name)
     (format-index category name)
     (format-refentry1-begin)
     (format-template name params)
     (format-category-and-location category location)
     (format-description description)
     (format-refentry1-end)
     (format-refentry-end))))

(define format-refentry-begin
  (lambda (name)
    (s+
"<!-- ================================================== -->
<refentry id=\"" (toString name) "\">
")))

(define (format-index category name)
  (s+
   "  <indexterm><primary>" (toString category) "</primary>
       <secondary>" (toString name) "</secondary></indexterm>
"))

(define format-refentry1-begin
  (lambda ()
    "  <refsect1>
"))

(define (format-template name params)
  (s+
"    <para><phrase id=\"template\">
      (<function>" (toString name) "</function>"
   (let ((result ""))
     (for-each (lambda (x)
		 (set! result (s+ result 
				  " <parameter>" 
				  (toString (second x))
				  "</parameter>")))
	       params)
     result)
")
    </phrase></para>
"))

(define format-category-and-location
  (lambda (category location)
    (s+
"    <para>
      <phrase id=\"category\">
        -- " (toString category) "
      </phrase>
      <phrase id=\"location\">
        -- <code>" (toString location) "</code>
      </phrase>
    </para>
")))

(define format-description
  (lambda (description)
    (let ((result ""))
      (for-each (lambda (x)
		  (set! result (s+ result (format-text-or-example x))))
		description)
      result)))

(define format-text-or-example
  (lambda (x)
    (cond ((and (pair? x) (eq? (car x) 'example))
	   (format-example (cdr x)))
	  ((pair? x)
	   (error "expected example"))
	  (else ;; REVISIT - check for string? - but make predicates builtin
	   (s+ "    <para>" x "</para>
")))))

(define format-example
  (lambda (example)
    (let ((result "
    <screen>
"))
      (for-each (lambda (x)
		  (set! result (s+ result x "
")))
		example)
      (s+ result "</screen>
"))))

(define format-refentry1-end
  (lambda () "  </refsect1>
"))

(define format-refentry-end
  (lambda () "</refentry>
"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;; Parsing -doc-
;;;;

(define parse-name
  (lambda (doc) (second (assq 'name doc))))

(define parse-category
  (lambda (doc)
    (let ((category (assq 'category doc)))
      (-if category
	   (second category)
	   'procedure))))

(define parse-location
  (lambda (doc) 
    (let ((location (assq 'location doc)))
      (-if location
	   (second location)
	   (list 'import *current-doc-package*)))))

(define parse-params
  (lambda (doc) (collect 'param doc)))

(define parse-result
  (lambda (doc) (collect 'result doc)))

(define parse-throws
  (lambda (doc) (collect 'throws doc)))

(define parse-description
  (lambda (doc) 
    (let ((description (assq 'description doc)))
      (-if description
	   (cdr description)
	   '()))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;; Implementation utilities
;;;;

(define (collect x doc)
  (let ((result (list 'dummy))) ;; NB: make a fresh list
    (do ((d doc (cdr d))
	 (rptr result 
	       (if (collect-match (caar d) x)
		   (begin
		     (setCdr rptr (cons (car d) '()))
		     (cdr rptr))
		   rptr)))
	((null? d) (cdr result)))))

(define collect-match
  (lambda (d x)
    (if (pair? x)
	(-if (memq d x)
	     true
	     false)
	(eq? x d))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;; Test
;;;;

(-comment-
;; cd .system
(import org.llava.lib.LlavaDoc)
(llava-doc "./org" "./doc/.generated")
(extract-doc-files (s+ (llava-dir) "/org/llava/lib/scm/Lists.lva") "/tmp/junk.xml")
(extract-doc
 '((package foo)
   (-doc-
    (name fooo)
    (param obj))
   (-doc-
    (name kill-current-thread)
    (description "Calls deprecated <function>stop</function> on the
      current thread."))))

(extract-doc
 '((package org.foo)
   (-doc-
    (name apply-fail-on-false)
    (param procedure "...")
    (param args "list")
    (result obj "like (<function>apply</function> <parameter>procedure</parameter> <parameter>args</parameter>)")
    (throws LlavaException "If result is false.")
    (description 
     "Identical to <function>apply</function> except it raises an
      exception if the result is false."
     (example "(apply (lambda (x) (pair? x)) '((1 . 2))) &lva-et; true")
     (example "(apply (lambda (x) (pair? x)) '(1)) &lva-te;")
    ))))

(extract-doc
 '((-doc-
    (name equal?)
    (param obj1)
    (param obj2)
    (location org.llava))))

)

;;; End of file.
