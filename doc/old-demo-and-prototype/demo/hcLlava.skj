;;;;
;;;; Created       : 1999 Jun 10 (Thu) 20:56:18 by Harold Carr.
;;;; Last Modified : 1999 Nov 17 (Wed) 21:54:36 by Harold Carr.
;;;;

;;;;
;;;; TODO
;;;;
;;;; * Get '()/#f consistent.
;;;; * Make abstract data type for parameters.
;;;;

(hcRequire "util")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;; Parser.
;;;;

(defmacro (hcLavaMakePredicate name test)
  `(define (,name item)
     (and (pair? item)
	  (member (first item) '(,test /** /* //)))))

(defmacro (hcLavaPopStream )
  `(begin
     (set! stream (rest stream))
     (set! item   (first stream))
     item))

(defmacro (hcLavaMakeParseItem name predicate)
  `(define (,name stream)
     (let ((result '())
	   (item (first stream)))
       (while (,predicate item)
	 (set! result (cons item result))
	 (hcLavaPopStream))
       (values (reverse result) stream))))

(hcLavaMakePredicate hcLavaCommentP    //) ; finds all comment forms
(hcLavaMakePredicate hcLavaPackageP    package)
(hcLavaMakePredicate hcLavaImportP     import)
(hcLavaMakePredicate hcLavaImplementsP implements)
(hcLavaMakePredicate hcLavaExtendsP    extends)
(hcLavaMakePredicate hcLavaThrowsP     throws)

(hcLavaMakeParseItem hcLavaParsePackage hcLavaPackageP)
(hcLavaMakeParseItem hcLavaParseImport  hcLavaImportP)

(defmacro (hcLavaGetImplementsOrExtends implementsOrExtends)
  `(begin
     (set! ,implementsOrExtends (first stream))
     (set! stream (rest stream))))

(define (hcLavaParseClassHeader stream)
  (let ((name       '())
	(implements '())
	(extends    '()))
    (if (or (not (eq? (first  stream) 'public))
	    (not (eq? (second stream) 'class)))
	(error (string-append "Expecting public class, got: "
			      (first stream) " " (second stream))))
    (setq name (third stream))
    (setq stream (rest (rest (rest stream))))
    (cond ((hcLavaImplementsP (first stream))
	   (hcLavaGetImplementsOrExtends implements)
	   (cond ((hcLavaExtendsP (first stream))
		  (hcLavaGetImplementsOrExtends extends))))
	  ((hcLavaExtendsP (first stream))
	   (hcLavaGetImplementsOrExtends extends)
	   (cond ((hcLavaImplementsP (first stream))
		  (hcLavaGetImplementsOrExtends implements)))))
    (values (hcLavaMakeClassHeader
	     :name name :implements implements :extends extends)
	    stream)))

(define (hcLavaParseClassMembers publicClassName stream)
  (hcLavaParseClassMember publicClassName '() (first stream) (rest stream)))

(define (hcLavaParseClassMember publicClassName accumulator stream remaining)
  (let ((visibility "")
	(static     "")
	(returnType #f)
	(name       '())
	(args       '())
	(throws     '())
	(body       '())
	(result     '())
	(item       (car stream)))
    (cond ((hcLavaCommentP stream)
	   (set! result stream))
	  (else
	   (cond ((member item '(public protected private))
		  (set! visibility item)
		  (hcLavaPopStream)))
	   (cond ((eq? item 'static)
		  (set! static item)
		  (hcLavaPopStream)))
	   (cond ((symbol? item)
		  (set! returnType item)
		  (hcLavaPopStream)
		  (let ((tmp (hcLavaParseNameAndParams item)))
		    (set! name (first tmp))
		    (set! args (second tmp))
		    (hcLavaPopStream)))
		 ((and (pair? item)
		       (eq? (car item) publicClassName))
		  ;; A Constructor.
		  (let ((tmp (hcLavaParseNameAndParams item)))
		    (set! name (first tmp))
		    (set! args (second tmp))
		    (hcLavaPopStream)))
		 (else
		  (error (string-append "Expecting name and parameters, got: "
					item))))
	   (cond ((hcLavaThrowsP item)
		  (set! throws item)
		  (hcLavaPopStream)))
	   ;; Build in throwing of SchemeException.
	   (cond ((null? throws)
		  (set! throws (list 'throws))))
	   (set! throws (append throws (list 'SchemeException)))
	   (set! body stream)
	   (set! result
		 (hcLavaMakeClassMember
		  :visibility visibility 
		  :static static
		  :returnType returnType 
		  :name name 
		  :args args
		  :throws throws
		  :body body))))
    (set! accumulator (cons result accumulator))
    (cond ((null? remaining)
	   (reverse accumulator))
	  (else
	   (hcLavaParseClassMember publicClassName
				   accumulator
				   (first remaining)
				   (rest remaining))))))

(define (hcLavaParseNameAndParams item)
  (values (first item) (rest item)))

(define (hcLavaParse def)
  (let* ((tmp1 (hcLavaParsePackage def))
	 (package (first tmp1))
	 (tmp2 (hcLavaParseImport (second tmp1)))
	 (import (first tmp2))
	 ;; NB. first to get inside the class and make a new stream.
	 (tmp3 (hcLavaParseClassHeader (first (second tmp2))))
	 (classHeader (first tmp3))
	 (members (hcLavaParseClassMembers 
		   (hcLavaGetClassHeaderName classHeader) (second tmp3))))
    `((package     ,package)
      (import      ,import)
      (classHeader ,classHeader)
      (members     ,members))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;; Java and Skij file generators.
;;;;

(define (hcLavaGenerateComment comment javaBuffer skijBuffer)
  (hcLavaGenerateCommentJava comment javaBuffer)
  (hcLavaGenerateCommentSkij comment skijBuffer))

(define (hcLavaGenerateCommentJava comment javaBuffer)
  (let* ((commentType (car comment))
	 (subsequent  (if (member commentType '(/** /*)) '* '//))
	 (end         (if (member commentType '(/** /*)) '*/ '//))
	 (needsSpaceP (if (member commentType '(/** /*)) #t #f)))
    (hcLavaTerpri javaBuffer)
    (hcLavaTerpri javaBuffer)
    (hcLavaPrinc commentType javaBuffer)
    (set! comment (cdr comment))
    (while (not (null? comment))
      (hcLavaTerpri javaBuffer)
      (if needsSpaceP (hcLavaPrinc " " javaBuffer))
      (hcLavaPrinc (string-append subsequent " " (car comment)) javaBuffer)
      (set! comment (cdr comment)))
    (hcLavaTerpri javaBuffer)
    (if needsSpaceP (hcLavaPrinc " " javaBuffer))
    (hcLavaPrinc end javaBuffer)
    (hcLavaTerpri javaBuffer)))

(define (hcLavaGenerateCommentSkij comment skijBuffer)
  (hcLavaTerpri skijBuffer)
  (hcLavaTerpri skijBuffer)
  (hcLavaPrintContents comment 
		       (lambda () (hcLavaPrinc ";;; " skijBuffer))
		       (lambda () (hcLavaTerpri skijBuffer))
		       skijBuffer
		       #f))

(define (hcLavaGeneratePackage parsed javaBuffer skijBuffer)
  (let ((package (hcLavaSelect 'package parsed)))
    (hcLavaGeneratePackageJava package javaBuffer)
    (hcLavaGeneratePackageSkij package skijBuffer)))

(define (hcLavaGeneratePackageJava package javaBuffer)
  (while (not (null? package))
    (cond ((hcLavaCommentP (car package))
	   (hcLavaGenerateCommentJava (car package) javaBuffer))
	  (else
	   (hcLavaTerpri javaBuffer)
	   (hcLavaPrinc (string-append "package " (second (car package)) ";")
			javaBuffer)))
    (set! package (cdr package))))

(define (hcLavaGeneratePackageSkij package skijBuffer)
  (while (not (null? package))
    (cond ((hcLavaCommentP (car package))
	   (hcLavaGenerateCommentSkij (car package) skijBuffer))
	  (else
	   (hcLavaTerpri skijBuffer)
	   (hcLavaPrinc (string-append ";;; " (car package)) skijBuffer)))
    (set! package (cdr package))))

(define (hcLavaGenerateImport parsed javaBuffer skijBuffer)
  (let ((import (hcLavaSelect 'import parsed)))
    (hcLavaGenerateImportJava import parsed javaBuffer)
    (hcLavaGenerateImportSkij import parsed skijBuffer)))

(define (hcLavaGenerateImportJava import parsed javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaPrinc "// Start of imports needed by framework." javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaPrinc "import com.ibm.jikes.skij.Cons;" javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaPrinc "import com.ibm.jikes.skij.Scheme;" javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaPrinc "import com.ibm.jikes.skij.SchemeException;" javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaPrinc "// End of imports needed by framework." javaBuffer)
  (hcLavaTerpri javaBuffer)
  (while (not (null? import))
    (cond ((hcLavaCommentP (car import))
	   (hcLavaGenerateCommentJava (car import) javaBuffer))
	  (else
	   (hcLavaTerpri javaBuffer)
	   (hcLavaPrinc (string-append "import " (second (car import)) ";")
			javaBuffer)))
    (set! import (cdr import))))

(define (hcLavaGenerateImportSkij import parsed skijBuffer)
  (hcLavaTerpri skijBuffer)
  (hcLavaPrinc "(hcRequire \"importJava\")" skijBuffer)
  (hcLavaTerpri skijBuffer)
  (let ((package (hcLavaSelect 'package (hcLavaSelect 'package parsed)))
	(className (hcLavaGetClassHeaderName
		    (hcLavaSelect 'classHeader parsed))))
    (hcLavaPrinc (string-append "(importJava \'" package "." className ")")
		 skijBuffer)
    (hcLavaTerpri skijBuffer))
  (while (not (null? import))
    (cond ((hcLavaCommentP (car import))
	   (hcLavaGenerateCommentSkij (car import) skijBuffer))
	  (else
	   (hcLavaTerpri skijBuffer)
	   (hcLavaPrinc (string-append ";;; " (car import)) skijBuffer)))
    (set! import (cdr import))))

(define (hcLavaGenerateClassHeader parsed javaBuffer skijBuffer)
  (let* ((classHeader (hcLavaSelect 'classHeader parsed))
	 (name        (hcLavaGetClassHeaderName       classHeader))
	 (implements  (hcLavaGetClassHeaderImplements classHeader))
	 (extends     (hcLavaGetClassHeaderExtends    classHeader)))
    (hcLavaTerpri javaBuffer)
    (hcLavaTerpri javaBuffer)
    (hcLavaPrinc (string-append "public class " name) javaBuffer)
    (hcLavaTerpri javaBuffer)
    (cond ((not (null? extends))
	   (hcLavaPrinc "extends" javaBuffer)
	   (hcLavaPrintContents (cdr extends)
				(lambda () (hcLavaTerpri javaBuffer))
				(lambda () #f)
				javaBuffer
				#t)
	   (hcLavaTerpri javaBuffer)))
    (cond ((not (null? implements))
	   (hcLavaPrinc "implements" javaBuffer)
	   (hcLavaPrintContents (cdr implements)
				(lambda () (hcLavaTerpri javaBuffer))
				(lambda () #f)
				javaBuffer
				#t)
	   (hcLavaTerpri javaBuffer)))
    (hcLavaPrinc "{" javaBuffer)))

(define (hcLavaGenerateMembers parsed javaBuffer skijBuffer)
  (let ((members (hcLavaSelect 'members parsed)))
    (while (not (null? members))
      (cond ((hcLavaCommentP (car members))
	     (hcLavaGenerateComment (car members) javaBuffer skijBuffer))
	    (else
	     (hcLavaGenerateMember (car members) parsed javaBuffer skijBuffer)))
      (set! members (cdr members)))))

(define (hcLavaGenerateMember member parsed javaBuffer skijBuffer)
  (hcLavaGenerateMemberJava member parsed javaBuffer)
  (hcLavaGenerateMemberSkij member parsed skijBuffer))

(define (hcLavaGenerateMemberJava member parsed javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaPrinc
   (string-append
    (hcLavaGetClassMemberVisibility member) " "
    (hcLavaGetClassMemberStatic member) " "
    (let ((returnType (hcLavaGetClassMemberReturnType member)))
      (if returnType returnType "")) " "
    (hcLavaGetClassMemberName member))
   javaBuffer)
  (hcLavaGenerateParametersJava (hcLavaGetClassMemberArgs member) javaBuffer)
  (let ((throws (hcLavaGetClassMemberThrows member)))
    (cond (throws
	   (hcLavaTerpri javaBuffer)
	   (hcLavaPrinc "throws" javaBuffer)
	   (hcLavaPrintContents (cdr throws)
				(lambda () (hcLavaTerpri javaBuffer))
				(lambda () #f)
				javaBuffer
				#t))))
  (hcLavaTerpri javaBuffer)
  (hcLavaPrinc "{" javaBuffer)
  (hcLavaGenerateBodyJava member parsed javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaPrinc "}" javaBuffer))

(define (hcLavaMakeProcNameSkij member parsed)
  (let ((package (hcLavaSelect 'package (hcLavaSelect 'package parsed)))
	(className 
	 (hcLavaGetClassHeaderName (hcLavaSelect 'classHeader parsed))))
    (string-append package
		   "."
		   className
		   "."
		   (symbol->string (hcLavaGetClassMemberName member))
		   "Impl")))

(define (hcLavaGenerateMemberSkij member parsed skijBuffer)
  (hcLavaTerpri skijBuffer)
  (let ((procName (hcLavaMakeProcNameSkij member parsed)))
    (hcLavaPrinc (string-append
		  "(define (" 
		  procName 
		  " "
		  (if (hcLavaNeedsThis? member) " this " "")
		  (hcLavaMakeParameterString 
		   (hcLavaGetClassMemberArgs member) #f #f)
		  ")")
		 skijBuffer))
  (let ((body (hcLavaGetClassMemberBody member)))
    (while (not (null? body))
      (hcLavaTerpri skijBuffer)
      (hcLavaPrin1 (car body) skijBuffer)
      (setq body (cdr body))))
  (hcLavaPrinc ")" skijBuffer))

(define (hcLavaMakeParameterString params withTypesP withCommasP)
  (let ((result ""))
    (while (not (null? params))
      (set! result
	    (string-append
	     result
	     (if withTypesP
		 (string-append
		  (first (first params)) " " (second (first params)))
		 (second (first params)))))
      (set! params (rest params))
      (if (not (null? params))
	  (set! result (string-append result (if withCommasP ", " " ")))))
    result))

(define (hcLavaGenerateParametersJava params javaBuffer)
  (hcLavaPrinc "(" javaBuffer)
  (hcLavaPrinc (hcLavaMakeParameterString params #t #t) javaBuffer)
  (hcLavaPrinc ")" javaBuffer))

(define (hcLavaNeedsThis? member)
  (if (eq? (hcLavaGetClassMemberStatic member) 'static)
      #f
      (if (hcLavaGetClassMemberArgs member) #t #f)))

(define (hcLavaGenerateBodyJava member parsed javaBuffer)
  (let ((returnType (hcLavaGetClassMemberReturnType member))
	(name       (hcLavaMakeProcNameSkij         member parsed))
	(args       (hcLavaGetClassMemberArgs       member)))
    (hcLavaTerpri javaBuffer)
    (cond ((and returnType
		(not (eq? returnType 'void)))
	   (hcLavaPrinc "return" javaBuffer)
	   (hcLavaTerpri javaBuffer)
	   (hcLavaPrinc (string-append "(" returnType ") ") javaBuffer)
	   (hcLavaTerpri javaBuffer)))
    (let* ((parms (hcLavaMakeParameterString args #f #t))
	   (applyArgs (if (hcLavaNeedsThis? member)
			  (if (null? args)
			      "Cons.list(this)"
			      (string-append "Cons.list(this, " parms ")"))
			  (if (null? args)
			      "Nil.nil"
			      (string-append "Cons.list(" parms ")")))))
      (hcLavaPrinc 
       (string-append
	"Scheme.procedure(\"" name "\").apply(" applyArgs ");")
       javaBuffer))))

(define (hcLavaGenerateCloseClass parsed javaBuffer skijBuffer)
  (hcLavaGenerateCloseClassJava parsed javaBuffer)
  (hcLavaGenerateCloseClassSkij parsed skijBuffer))

(define (hcLavaGenerateCloseClassJava parsed javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaPrinc "}" javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaPrinc "// End of file." javaBuffer)
  (hcLavaTerpri javaBuffer))

(define (hcLavaGenerateCloseClassSkij parsed skijBuffer)
  (hcLavaTerpri skijBuffer)
  (hcLavaTerpri skijBuffer)
  (hcLavaPrinc ";;; End of file." skijBuffer)
  (hcLavaTerpri skijBuffer))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;; Top level.
;;;;

(defmacro (define-java-class . def)
  `(define-java-class-e ',def))

(define (define-java-class-e def)
  (let* ((parsed       (hcLavaParse def))
	 (className    (symbol->string 
			(hcLavaGetClassHeaderName
			 (hcLavaSelect 'classHeader parsed))))
	 (javaFileName (string-append className ".java"))
	 (skijFileName (string-append className "Impl.skj"))
	 (javaBuffer   (open-output-file javaFileName))
	 (skijBuffer   (open-output-file skijFileName)))
    (for-each
     (lambda (procedure)
       (procedure parsed javaBuffer skijBuffer))
     `(,hcLavaGeneratePackage
       ,hcLavaGenerateImport
       ,hcLavaGenerateClassHeader
       ,hcLavaGenerateMembers
       ,hcLavaGenerateCloseClass))
    (close-output-port javaBuffer)
    (close-output-port skijBuffer)
    #t))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;; Utilities.
;;;;

;;; Records

(define (hcLavaCheckRecordType record type)
  (if (or (not (pair? record))
	  (not (eq? (car record) type)))
      (error (string-append "Incorrect type.  Expected: "
			    type
			    " got: "
			    record))))
(define (hcLavaGetRecordSlot record slot)
  (let ((found (member slot record)))
    (if (not found)
	(error (string-append "Incorrect slot: " slot " for: " record)))
    (cadr found)))
(define (hcLavaCheckGetRecordSlot type record slot)
  (hcLavaCheckRecordType record type)
  (hcLavaGetRecordSlot record slot))

;;; ClassHeader

(defineWithKeywords (hcLavaMakeClassHeader name implements extends)
  (list 'ClassHeader
	:name name 
	:implements implements
	:extends extends))
(define (hcLavaGetClassHeaderName record)
  (hcLavaCheckGetRecordSlot 'ClassHeader record :name))
(define (hcLavaGetClassHeaderImplements record)
  (hcLavaCheckGetRecordSlot 'ClassHeader record :implements))
(define (hcLavaGetClassHeaderExtends record)
  (hcLavaCheckGetRecordSlot 'ClassHeader record :extends))

;;; ClassMember

(defineWithKeywords (hcLavaMakeClassMember
		     visibility static returnType name args throws body)
  (list 'ClassMember 
	:visibility visibility 
	:static static
	:returnType returnType 
	:name name 
	:args args
	:throws throws
	:body body))
(define (hcLavaGetClassMemberVisibility record)
  (hcLavaCheckGetRecordSlot 'ClassMember record :visibility))
(define (hcLavaGetClassMemberStatic record)
  (hcLavaCheckGetRecordSlot 'ClassMember record :static))
(define (hcLavaGetClassMemberReturnType record)
  (hcLavaCheckGetRecordSlot 'ClassMember record :returnType))
(define (hcLavaGetClassMemberName record)
  (hcLavaCheckGetRecordSlot 'ClassMember record :name))
(define (hcLavaGetClassMemberArgs record)
  (hcLavaCheckGetRecordSlot 'ClassMember record :args))
(define (hcLavaGetClassMemberThrows record)
  (hcLavaCheckGetRecordSlot 'ClassMember record :throws))
(define (hcLavaGetClassMemberBody record)
  (hcLavaCheckGetRecordSlot 'ClassMember record :body))


(define (hcLavaSelect this that)
  (cond ((null? that) '())
	((eq? this (caar that)) (car (cdr (car that))))
	(else (hcLavaSelect this (cdr that)))))

(define (hcLavaPrintContents 
	 contents beforeEachItem afterEachItem stream withCommas?)
  (while (not (null? contents))
    (let ((x (car contents)))
      (set! contents (cdr contents))
      (beforeEachItem)
      (hcLavaPrinc x stream)
      (if (and withCommas?
	       (not (null? contents)))
	  (hcLavaPrinc "," stream))
      (afterEachItem))))

(define (hcLavaTerpri stream)
  (newline stream))

(define (hcLavaPrinc item stream)
  (display item stream))

(define (hcLavaPrin1 item stream)
  (write item stream))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;; Test
;;;;

(comment

(load "hcLava.skj")

(define-java-class
  (package hc.lava)
  (public class FooImplGen (extends Foo)
	  (public String (bar (String x))
		  (string-append "it works!  "
				 (to-string this)
				 (to-string x)))))

;. ripEnvHc
gm

(define className 'nothing)
;(set! className 'hc.lava.FooImpl)
(set! className 'hc.lava.FooImplGen)
(define (tryFoo)
  (let ((foo (new className)))
    (bar foo " The Argument")))

;; Define by hand.
(hcRequire "importJava")
(importJava className)
(define (barImpl this x)
  (string-append "it works by hand!  " (to-string this) (to-string x)))

(tryFoo)

;; Define by gen.
(load "FooImplGenImpl.skj")
  
(tryFoo)


;;-----------

(load "hcLava.skj")

(define-java-class
  (/** "Comment before package."
       "Each line in a string.")
  (package hc.lava)
  (/* "Comment before import."
      "Another line.")
  (import com.ibm.jikes.skij.*)
  (import java.util.Hashtable)
  (// "Comment before class."
      "Another line.")
  (public class Baz (implements Wombat)
	            (extends Foo)
	  (/** "Constructor with no args.")
	  (public (Baz) 
		  (print "Baz no arg constructor"))
	  ;(/** "Constructor with args.")
	  ;(public (Baz x)
	  ;        (print (list "Baz constructor with arg" x)))
	  (/* "Static method with no args.")
	  (public static void (barNo)
		  (print "barNo"))
	  (/* "Static method with args.")
	  (public static Object (barYes (Object x) (Hashtable y))
		  (let ((return (list 'public 'static 'Object 'barYes x)))
		    (print return)
		    return))
	  (// "Virtual method with no args.")
	  (public void (bazNo)
		  (print "bazNo"))
	  (// "Virtual method with args.")
	  (public Object (bazYes (Object x)) (throws SomeException)
		  `(public Object baz ,x))))

;. ripEnvHc
gm

(define (tryBaz)
  (let ((foo (new 'hc.lava.Baz)))
    (hc.lava.Baz.barNo)
    (hc.lava.Baz.barYes (new 'java.lang.Integer 1) (new 'java.util.Hashtable))
    (bazNo foo)
    (bazYes foo (new 'java.lang.Integer 2))))

(load "BazImpl.skj")
(tryBaz)

)

;;; End of file.

