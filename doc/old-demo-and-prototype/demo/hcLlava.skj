;;;;
;;;; Created       : 1999 Jun 10 (Thu) 20:56:18 by Harold Carr.
;;;; Last Modified : 1999 Nov 17 (Wed) 12:48:04 by Harold Carr.
;;;;

;;;;
;;;; TODO
;;;;
;;;; * Prepend package path to lava IMPL method names.
;;;; * Get '()/#f consistent.
;;;;

(hcRequire "util")

;;;;
;;;; Parser.
;;;;

(defmacro (hcLavaMakePredicate name test)
  `(define (,name item)
     (and (pair? item)
	  (member (first item) '(,test /** /* //)))))

(defmacro (hcLavaPopStream )
  `(begin
     (set! stream (rest stream))
     (set! item   (first stream))
     item))

(defmacro (hcLavaMakeParseItem name predicate)
  `(define (,name stream)
     (let ((result '())
	   (item (first stream)))
       (while (,predicate item)
	 (set! result (cons item result))
	 (hcLavaPopStream))
       (values (reverse result) stream))))

(hcLavaMakePredicate hcLavaCommentP    //) ; finds all comment forms
(hcLavaMakePredicate hcLavaPackageP    package)
(hcLavaMakePredicate hcLavaImportP     import)
(hcLavaMakePredicate hcLavaImplementsP implements)
(hcLavaMakePredicate hcLavaExtendsP    extends)
(hcLavaMakePredicate hcLavaThrowsP     throws)

(hcLavaMakeParseItem hcLavaParsePackage hcLavaPackageP)
(hcLavaMakeParseItem hcLavaParseImport  hcLavaImportP)

(defmacro (hcLavaGetImplementsOrExtends implementsOrExtends)
  `(begin
     (set! ,implementsOrExtends (first stream))
     (set! stream (rest stream))))

(define (hcLavaParseClassHeader stream)
  (let ((name       '())
	(implements '())
	(extends    '()))
    (if (or (not (eq? (first  stream) 'public))
	    (not (eq? (second stream) 'class)))
	(error (string-append "Expecting public class, got: "
			      (first stream) " " (second stream))))
    (setq name (third stream))
    (setq stream (rest (rest (rest stream))))
    (cond ((hcLavaImplementsP (first stream))
	   (hcLavaGetImplementsOrExtends implements)
	   (cond ((hcLavaExtendsP (first stream))
		  (hcLavaGetImplementsOrExtends extends))))
	  ((hcLavaExtendsP (first stream))
	   (hcLavaGetImplementsOrExtends extends)
	   (cond ((hcLavaImplementsP (first stream))
		  (hcLavaGetImplementsOrExtends implements)))))
    (values (list name implements extends) stream)))

(define (hcLavaParseClassMembers publicClassName stream)
  (hcLavaParseClassMember publicClassName '() (first stream) (rest stream)))

(define (hcLavaParseClassMember publicClassName accumulator stream remaining)
  (let ((visibility "")
	(static     "")
	(returnType #f)
	(name       '())
	(args       '())
	(throws     '())
	(body       '())
	(result     '())
	(item       (car stream)))
    (cond ((hcLavaCommentP stream)
	   (set! result stream))
	  (else
	   (cond ((member item '(public protected private))
		  (set! visibility item)
		  (hcLavaPopStream)))
	   (cond ((eq? item 'static)
		  (set! static item)
		  (hcLavaPopStream)))
	   (cond ((symbol? item)
		  (set! returnType item)
		  (hcLavaPopStream)
		  (let ((tmp (hcLavaParseNameAndParams item)))
		    (set! name (first tmp))
		    (set! args (second tmp))
		    (hcLavaPopStream)))
		 ((and (pair? item)
		       (eq? (car item) publicClassName))
		  ;; A Constructor.
		  (let ((tmp (hcLavaParseNameAndParams item)))
		    (set! name (first tmp))
		    (set! args (second tmp))
		    (hcLavaPopStream)))
		 (else
		  (error (string-append "Expecting name and parameters, got: "
					item))))
	   (cond ((hcLavaThrowsP item)
		  (set! throws item)
		  (hcLavaPopStream)))
	   ;; Build in throwing of SchemeException.
	   (cond ((null? throws)
		  (set! throws (list 'throws))))
	   (set! throws (append throws (list 'SchemeException)))
	   (set! body stream)
	   (set! result
		 `(,visibility ,static ,returnType ,name ,args ,throws ,body))))
    (set! accumulator (cons result accumulator))
    (cond ((null? remaining)
	   (reverse accumulator))
	  (else
	   (hcLavaParseClassMember publicClassName
				   accumulator
				   (first remaining)
				   (rest remaining))))))

(define (hcLavaParseNameAndParams item)
  (values (first item) (rest item)))

(define (hcLavaParse def)
  (let* ((tmp1 (hcLavaParsePackage def))
	 (package (first tmp1))
	 (tmp2 (hcLavaParseImport (second tmp1)))
	 (import (first tmp2))
	 ;; NB. first to get inside the class and make a new stream.
	 (tmp3 (hcLavaParseClassHeader (first (second tmp2))))
	 (classHeader (first tmp3))
	 (members (hcLavaParseClassMembers (first classHeader) (second tmp3))))
    `((package     ,package)
      (import      ,import)
      (classHeader ,classHeader)
      (members     ,members))))

;;;;
;;;; Java and Skij file generators.
;;;;

(define (hcLavaGenerateComment comment javaBuffer skijBuffer)
  (hcLavaGenerateCommentJava comment javaBuffer)
  (hcLavaGenerateCommentSkij comment skijBuffer))

(define (hcLavaGenerateCommentJava comment javaBuffer)
  (let* ((commentType (car comment))
	 (subsequent  (if (member commentType '(/** /*)) '* '//))
	 (end         (if (member commentType '(/** /*)) '*/ '//))
	 (needsSpaceP (if (member commentType '(/** /*)) #t #f)))
    (hcLavaTerpri javaBuffer)
    (hcLavaTerpri javaBuffer)
    (hcLavaPrinc commentType javaBuffer)
    (set! comment (cdr comment))
    (while (not (null? comment))
      (hcLavaTerpri javaBuffer)
      (if needsSpaceP (hcLavaPrinc " " javaBuffer))
      (hcLavaPrinc (string-append subsequent " " (car comment)) javaBuffer)
      (set! comment (cdr comment)))
    (hcLavaTerpri javaBuffer)
    (if needsSpaceP (hcLavaPrinc " " javaBuffer))
    (hcLavaPrinc end javaBuffer)
    (hcLavaTerpri javaBuffer)))

(define (hcLavaGenerateCommentSkij comment skijBuffer)
  (hcLavaTerpri skijBuffer)
  (hcLavaTerpri skijBuffer)
  (hcLavaPrintContents comment 
		       (lambda () (hcLavaPrinc ";;; " skijBuffer))
		       (lambda () (hcLavaTerpri skijBuffer))
		       skijBuffer
		       #f))

(define (hcLavaGeneratePackage parsed javaBuffer skijBuffer)
  (let ((package (hcLavaSelect 'package parsed)))
    (hcLavaGeneratePackageJava package javaBuffer)
    (hcLavaGeneratePackageSkij package skijBuffer)))

(define (hcLavaGeneratePackageJava package javaBuffer)
  (while (not (null? package))
    (cond ((hcLavaCommentP (car package))
	   (hcLavaGenerateCommentJava (car package) javaBuffer))
	  (else
	   (hcLavaTerpri javaBuffer)
	   (hcLavaPrinc (string-append (first (car package))
				       " "
				       (second (car package))
				       ";")
			javaBuffer)))
    (set! package (cdr package))))

(define (hcLavaGeneratePackageSkij package skijBuffer)
  (while (not (null? package))
    (cond ((hcLavaCommentP (car package))
	   (hcLavaGenerateCommentSkij (car package) skijBuffer))
	  (else
	   (hcLavaTerpri skijBuffer)
	   (hcLavaPrinc (string-append ";;; " (car package)) skijBuffer)))
    (set! package (cdr package))))

(define (hcLavaGenerateImport parsed javaBuffer skijBuffer)
  (let ((import (hcLavaSelect 'import parsed)))
    (hcLavaGenerateImportJava import javaBuffer)
    (hcLavaGenerateImportSkij parsed import skijBuffer
			      (hcLavaSelect 'package parsed))))

(define (hcLavaGenerateImportJava import javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaPrinc "// Start of imports needed by framework." javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaPrinc "import com.ibm.jikes.skij.Cons;" javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaPrinc "import com.ibm.jikes.skij.Scheme;" javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaPrinc "import com.ibm.jikes.skij.SchemeException;" javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaPrinc "// End of imports needed by framework." javaBuffer)
  (hcLavaTerpri javaBuffer)
  (while (not (null? import))
    (cond ((hcLavaCommentP (car import))
	   (hcLavaGenerateCommentJava (car import) javaBuffer))
	  (else
	   (hcLavaTerpri javaBuffer)
	   (hcLavaPrinc (string-append (first (car import))
				       " "
				       (second (car import))
				       ";")
			javaBuffer)))
    (set! import (cdr import))))

(define (hcLavaGenerateImportSkij parsed import skijBuffer package)
  (hcLavaTerpri skijBuffer)
  (hcLavaPrinc "(hcRequire \"importJava\")" skijBuffer)
  (hcLavaTerpri skijBuffer)
  (let ((package   (hcLavaSelect 'package package))
	(className (first (hcLavaSelect 'classHeader parsed))))
    (hcLavaPrinc (string-append "(importJava \'" package "." className ")")
		 skijBuffer)
    (hcLavaTerpri skijBuffer))
  (while (not (null? import))
    (cond ((hcLavaCommentP (car import))
	   (hcLavaGenerateCommentSkij (car import) skijBuffer))
	  (else
	   (hcLavaTerpri skijBuffer)
	   (hcLavaPrinc (string-append ";;; " (car import)) skijBuffer)))
    (set! import (cdr import))))

(define (hcLavaGenerateClassHeader parsed javaBuffer skijBuffer)
  (let ((classHeader (hcLavaSelect 'classHeader parsed)))
    (hcLavaTerpri javaBuffer)
    (hcLavaTerpri javaBuffer)
    (hcLavaPrinc (string-append "public class " (first classHeader))
		 javaBuffer)
    (hcLavaTerpri javaBuffer)
    (hcLavaPrinc (car (third classHeader)) javaBuffer)
    (hcLavaPrintContents (cdr (third classHeader))
			 (lambda () (hcLavaTerpri javaBuffer))
			 (lambda () #f)
			 javaBuffer
			 #t)
    (hcLavaTerpri javaBuffer)
    (hcLavaPrinc (car (second classHeader)) javaBuffer)
    (hcLavaPrintContents (cdr (second classHeader))
			 (lambda () (hcLavaTerpri javaBuffer))
			 (lambda () #f)
			 javaBuffer
			 #t)
    (hcLavaTerpri javaBuffer)
    (hcLavaPrinc "{" javaBuffer)))

(define (hcLavaGenerateMembers parsed javaBuffer skijBuffer)
  (let ((members (hcLavaSelect 'members parsed)))
    (while (not (null? members))
      (cond ((hcLavaCommentP (car members))
	     (hcLavaGenerateComment (car members) javaBuffer skijBuffer))
	    (else
	     (hcLavaGenerateMember (car members) javaBuffer skijBuffer)))
      (set! members (cdr members)))))

(define (hcLavaGenerateMember member javaBuffer skijBuffer)
  (hcLavaGenerateMemberJava member javaBuffer)
  (hcLavaGenerateMemberSkij member skijBuffer))

(define (hcLavaGenerateMemberJava member javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaPrinc
   (string-append
    (first member) " "
    (second member) " "
    (if (third member) (third member) "") " "
    (fourth member))
   javaBuffer)
  (hcLavaGenerateParametersJava (fifth member) javaBuffer)
  (cond ((sixth member)
	 (hcLavaTerpri javaBuffer)
	 (hcLavaPrinc "throws" javaBuffer)
	 (hcLavaPrintContents (cdr (sixth member))
			      (lambda () (hcLavaTerpri javaBuffer))
			      (lambda () #f)
			      javaBuffer
			      #t)))
  (hcLavaTerpri javaBuffer)
  (hcLavaPrinc "{" javaBuffer)
  (hcLavaGenerateBodyJava member javaBuffer javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaPrinc "}" javaBuffer))

(define (hcLavaGenerateMemberSkij member skijBuffer)
  (hcLavaTerpri skijBuffer)
  (hcLavaPrinc (string-append
		"(define ("
		(symbol->string (fourth member)) "Impl "
		(if (hcLavaNeedsThis? member) " this " "")
		(hcLavaMakeParameterString (fifth member) #f #f)
		")")
	       skijBuffer)
  (let ((body (seventh member)))
    (while (not (null? body))
      (hcLavaTerpri skijBuffer)
      (hcLavaPrin1 (car body) skijBuffer)
      (setq body (cdr body))))
  (hcLavaPrinc ")" skijBuffer))

(define (hcLavaMakeParameterString params withTypesP withCommasP)
  (let ((result ""))
    (while (not (null? params))
      (set! result
	    (string-append
	     result
	     (if withTypesP
		 (string-append
		  (first (first params)) " " (second (first params)))
		 (second (first params)))))
      (set! params (rest params))
      (if (not (null? params))
	  (set! result (string-append result (if withCommasP ", " " ")))))
    result))

(define (hcLavaGenerateParametersJava params javaBuffer)
  (hcLavaPrinc "(" javaBuffer)
  (hcLavaPrinc (hcLavaMakeParameterString params #t #t) javaBuffer)
  (hcLavaPrinc ")" javaBuffer))

(define (hcLavaNeedsThis? member)
  (if (eq? (second member) 'static)
      #f
      (if (fifth member) #t #f)))

(define (hcLavaGenerateBodyJava member javaBuffer skijBuffer)
  (hcLavaTerpri javaBuffer)
  (cond ((and (third member)
	      (not (eq? (third member) 'void)))
	 (hcLavaPrinc "return" javaBuffer)
	 (hcLavaTerpri javaBuffer)
	 (hcLavaPrinc (string-append "(" (third member)") ") javaBuffer)
	 (hcLavaTerpri javaBuffer)))
  (let* ((baseName (fourth member))
	 (parms (hcLavaMakeParameterString (fifth member) #f #t))
	 (applyArgs (if (hcLavaNeedsThis? member)
			(if (null? (fifth member))
			    "Cons.list(this)"
			    (string-append "Cons.list(this, " parms ")"))
			(if (null? (fifth member))
			    "Nil.nil"
			    (string-append "Cons.list(" parms ")")))))
    (hcLavaPrinc 
     (string-append
      "Scheme.procedure(\"" baseName "Impl\").apply(" applyArgs ");")
     javaBuffer)))

(define (hcLavaGenerateCloseClass parsed javaBuffer skijBuffer)
  (hcLavaGenerateCloseClassJava parsed javaBuffer)
  (hcLavaGenerateCloseClassSkij parsed skijBuffer))

(define (hcLavaGenerateCloseClassJava parsed javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaPrinc "}" javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaTerpri javaBuffer)
  (hcLavaPrinc "// End of file." javaBuffer)
  (hcLavaTerpri javaBuffer))

(define (hcLavaGenerateCloseClassSkij parsed skijBuffer)
  (hcLavaTerpri skijBuffer)
  (hcLavaTerpri skijBuffer)
  (hcLavaPrinc ";;; End of file." skijBuffer)
  (hcLavaTerpri skijBuffer))

;;;;
;;;; Top level.
;;;;

(defmacro (define-java-class . def)
  `(define-java-class-e ',def))

(define (define-java-class-e def)
  (let* ((parsed       (hcLavaParse def))
	 (className    (symbol->string (first (hcLavaSelect 'classHeader parsed))))
	 (javaFileName (string-append className ".java"))
	 (skijFileName (string-append className "Impl.skj"))
	 (javaBuffer   (open-output-file javaFileName))
	 (skijBuffer   (open-output-file skijFileName)))
    (for-each
     (lambda (procedure)
       (procedure parsed javaBuffer skijBuffer))
     `(,hcLavaGeneratePackage
       ,hcLavaGenerateImport
       ,hcLavaGenerateClassHeader
       ,hcLavaGenerateMembers
       ,hcLavaGenerateCloseClass))
    (close-output-port javaBuffer)
    (close-output-port skijBuffer)
    #t))
    
;;;;
;;;; Utilities.
;;;;

(define (rest x) (cdr x))
(define (first x) (car x))
(define (second x) (cadr x))
(define (third x) (caddr x))
(define (fourth x) (car (cdddr x)))
(define (fifth x) (cadr (cdddr x)))
(define (sixth x) (car (cddr (cdddr x))))
(define (seventh x) (cadr (cddr (cdddr x))))
(define (caddr x) (cadr (cdr x)))
(define (cdddr x) (cddr (cdr x)))
(define (values . x) x)

(define (hcLavaSelect this that)
  (cond ((null? that) '())
	((eq? this (caar that)) (car (cdr (car that))))
	(else (hcLavaSelect this (cdr that)))))

(define (hcLavaPrintContents 
	 contents beforeEachItem afterEachItem stream withCommas?)
  (while (not (null? contents))
    (let ((x (car contents)))
      (set! contents (cdr contents))
      (beforeEachItem)
      (hcLavaPrinc x stream)
      (if (and withCommas?
	       (not (null? contents)))
	  (hcLavaPrinc "," stream))
      (afterEachItem))))

(define (hcLavaTerpri stream)
  (newline stream))

(define (hcLavaPrinc item stream)
  (display item stream))

(define (hcLavaPrin1 item stream)
  (write item stream))

;;;;
;;;; Test
;;;;

(comment

(load "hcLava.skj")

(define-java-class
  (package hc.util)
  (public class FooImplGen (extends Foo)
	  (public String (bar (String x))
		  (string-append "it works!  "
				 (to-string this)
				 (to-string x)))))

;. ripEnvHc
cp Foo.java            ../hc/tmp
cp FooImplGen.java     ../hc/tmp
pushd                  ../hc/tmp
gm

(define className 'nothing)
;(set! className 'hc.tmp.FooImpl)
(set! className 'hc.tmp.FooImplGen)
(define (tryFoo)
  (let ((foo (new className)))
    (bar foo " The Argument")))

;; Define by hand.
(hcRequire "importJava")
(importJava className)
(define (barImpl this x)
  (string-append "it works by hand!  " (to-string this) (to-string x)))

(tryFoo)

;; Define by gen.
(load "FooImplGenImpl.skj")
  
(tryFoo)


;;-----------

(load "hcLava.skj")

(define-java-class
  (/** "Comment before package."
       "Each line in a string.")
  (package hc.tmp)
  (/* "Comment before import."
      "Another line.")
  (import com.ibm.jikes.skij.*)
  (import java.util.Hashtable)
  (// "Comment before class."
      "Another line.")
  (public class Baz (implements Wombat)
	            (extends Foo)
	  (/** "Constructor with no args.")
	  (public (Baz) 
		  (print "Baz no arg constructor"))
	  ;(/** "Constructor with args.")
	  ;(public (Baz x)
	  ;        (print (list "Baz constructor with arg" x)))
	  (/* "Static method with no args.")
	  (public static void (barNo)
		  (print "barNo"))
	  (/* "Static method with args.")
	  (public static Object (barYes (Object x) (Hashtable y))
		  (let ((return (list 'public 'static 'Object 'barYes x)))
		    (print return)
		    return))
	  (// "Virtual method with no args.")
	  (public void (bazNo)
		  (print "bazNo"))
	  (// "Virtual method with args.")
	  (public Object (bazYes (Object x)) (throws SomeException)
		  `(public Object baz ,x))))

;. ripEnvHc
cp Baz.java            ../hc/tmp
pushd                  ../hc/tmp
gm

(define (tryBaz)
  (let ((foo (new 'hc.tmp.Baz)))
    (hc.tmp.Baz.barNo)
    (hc.tmp.Baz.barYes (new 'java.lang.Integer 1) (new 'java.util.Hashtable))
    (bazNo foo)
    (bazYes foo (new 'java.lang.Integer 2))))

(load "BazImpl.skj")
(tryBaz)

)

;;; End of file.

