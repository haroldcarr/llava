Copyright (c) 1997 - 2004 Harold Carr

This work is licensed under the Creative Commons Attribution License.
To view a copy of this license, visit 
  http://creativecommons.org/licenses/by/2.0/
or send a letter to
  Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.
------------------------------------------------------------------------------

Created       : 1999 Dec 18 (Sat) 17:14:40 by Harold Carr.
Last Modified : 2004 Sep 06 (Mon) 01:46:25 by Harold Carr.

To do:

* doc embedded and script

* Make defmacro builtin.

* Fix reader error: (string-append " (" "3" ")")

* Todo in namespaceimpl.

* Think about built-ins/lib using hypens so no need to be Java/dynamic.

* Need to be able to coerce to short, byte
	e.g., try creating a org.omg.IOP.Encoding

* Check out how to deal with inner class creation/refer from llava syntax level.

* DII - NullPointerException when static invoke on dynamic method/class:
eg: (-si 'getFullNameNamespaceMapKeys 'testLlava.proto.NamespaceImpl)

------------------------------------------------------------------------------
Before initial release:

* reader: "," does unquote

* # reading when not character: e.g., #160 -> 160 #newline -> 'newline

* test load from emacs with (-comment-

* checkNumArgs

* PrimNot

* 1. Rewrite DII (i.e., dynvoke - call it Reflect, or DII).
	DII and DIIImpl.  -> PrimInvoke (etc.) will then need DII instance.
  2. Enable auto-generic toggling

* reader: make object eq constants for all tokens.

* Make scheme IF be default.

* lambda, assignment, etc as pluggable syntax rather than built
  into the compiler.

* Interface and *Impl for all Prim* Code* etc.

* Make other procedures like c*r as generics off of Pair rather
  than explicit primitives.

* Make undefinedIdHandler into two distinct classes rather than anonymous.

* define-final (use on lambdas, not generics).

* Internally use define and define-final rather than set

* Implement pluggability in factories.
  Plus, do not create individual type factories until needed.

* Check close after load - and check logic of PrimLoad

* make .print/display/newline use current std out (in repl).

------------------------------------------------------------------------------
Near term:

* Optimize
	startup 
		- collect all derived into one internal string.
		- or convert derived into explicit Java code.
		- or speed up system itself so code runs faster (do this first)
	Enable non-generic version which explicitly has primitives
		in one class and switch statement in apply.

* support serialization of Llava

* Enable anonymous classes for primitives (and maybe use them).

* Factor primitive invoke/field methods.

* try code running without compiler or repl

* javadoc llava

* LlavaInteger subtype of Integer which preallocates range: ?-128.

* LlavaDouble  subtype of Double  which preallocates 0.0, 1.0, ?

* If you see a message like:

Error: java.lang.Exception: setq: not enough arguments

it means you defined a macro *AFTER* you referenced it.
Example:

(begin 
  (require 'org/llava/lib/cl/control/setq)
  (setq a 34))

That is because Llava is apply the syntax procedure for setq
to the list (1 34) but the expander expects two arguments.

------------------------------------------------------------------------------
Create classes on the fly:

(package
 (import org.llava.lib.java.util.Hashtable)
 (public class MyPair
	 (implements some.Interface) // either full name or name-space support
	 (extends    some.Class)
   (private Object _car)             // only private fields
   (private Object _cdr)
   (private Hashtable _shared)
   (public (MyPair car cdr)
	   (set! _car car)
	   (set! _cdr cdr))
   (public Object (car) _car)
   (public Object (cdr) _cdr)
   (public Object (set-car! v) (set! _car v) v)
   (public Object (set-cdr! v) (set! _cdr v) v)))

Compile MyPair to a byte-coded interface.

Then proxy:

(let ((_car null)
      (_cdr null)
      (_shared null))
  // proxy stuff here
  )

Need new support for:

(new 'MyPair 'a 'b)

------------------------------------------------------------------------------
Someday:

* Visit "REVISIT" in code.

* REVISIT ThreadDeath in EngineImpl and GenericProcedureImpl.

* Reconsider undefined turning in GenericProcedure.
  Obviates define before set!.

* Macro handling - right now it seems they must be defined first.

* Macros lambdas always get top level environment.
  SHould get current lexical environment.  See SyntaxDefineSyntax.lva

(let ((test -1))
  (define foo (lambda () foo)))
(getSavedFrame foo)
(let ((test -1))
  (define-syntax bar (lambda () foo)))
(getSavedFrame (getMacroLambda bar))

* Write Scheme write (i.e., String printing, quotes, characters).

* Macroexpand and prettyprint.

* Llava and Repl should go in libLlava?

* Architecture

	- top level and what is passed between compiler and evaluator.
	- environments.
	   Runtime
		Top
		Frame
	   Compiletime
		Lexical
		Macro env ?? (probably should go in top or frame).

* Write R5RS compiler/runtime.
  Useful and demonstrates plugability/reusablity.

;; End of file.


