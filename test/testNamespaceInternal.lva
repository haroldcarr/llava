;;;;
;;;; Created       : 2000 Oct 21 (Sat) 10:46:48 by Harold Carr.
;;;; Last Modified : 2004 Dec 22 (Wed) 10:37:38 by Harold Carr.
;;;;

;; TODO:
;;
;; - Implement importJavaClassIntoCurrentPackage
;;
;; - Use classpath to search for .lva/.class files.
;;   For each path first look for .lva then .class if not found
;;   then next path if not found.
;;
;; - try/catch should know about current imports
;;   (like new does - or rather will)
;;
;; - Same goes for instanceof.  What else?
;;
;; - Convert to Java.
;;
;; - Integrate with Lava.

;; Think about:
;;
;; * From any package you must import to enable BOTH short and long references.
;;   In other words, only can ref imported things.
;;
;; * Have import precompute as much reflection as possible on all methods
;;   on each class to avoid full DI.

(require 'test/test)

(define *fullNameNamespaceMap* ; Used to find existing namespaces.
  (new 'java.util.Hashtable))

(define (findNamespace name)
  (get *fullNameNamespaceMap* name))

(define (createNamespace name)
  ;; This should not be called if the name exists.
  ;; It does not check.  It just overwrites in that case.
  (let ((ns (new 'testLava.proto.Namespace name *rootNamespace*)))
    (put *fullNameNamespaceMap* name ns)
    ns))

(define (findOrCreateNamespace name)
  (let ((ns (findNamespace name)))
    (if (null? ns)
        (createNamespace name)
	ns)))


;; N.B.: Each namespace always contains the topLevelNamespace
;; at the end of its refList.  During initialization we need to
;; explicitly remove this reference - both because it doesn't
;; exist so it is null - and if it did exist would cause a circular
;; lookup.
;; REVISIT: access to lava.Lava.foo via .foo

(define *rootNamespace* null) ; Contains the built-in system procedures.
(set! *rootNamespace* (createNamespace "lava.Lava"))
(remove (getRefList *rootNamespace*) 1)


;; The system starts in the REPL namespace.

(define *replNamespace* (createNamespace "lava.REPL"))


;; package switches the current namespace.

(define *currentNamespace* *replNamespace*)


;;;
;;; Returns a list of the namespaces imported by a namespace
;;; in reference order (i.e., most recent to root).
;;;

(define (getRefListNames ns)
  (let ((refList (getRefList ns)))
    (do ((result '()    
		 (cons (getName (elementAt refList i)) result))
	 (i      (- (size refList) 1) 
		 (- i 1)))
	((= i -1) result))))


;; For testing only.  Returns results in alpha order.

(define (getFullNameNamespaceMapKeys)
  (do ((keys (keys *fullNameNamespaceMap*))
       (arrayList (new 'java.util.ArrayList) 
		  (begin (add arrayList (next keys))
			 arrayList)))
      ((not (hasNext keys)) 
       (_si 'sort 'java.util.Collections arrayList)
       (do ((i (- (size arrayList) 1) (- i 1))
	    (result '() (cons (get arrayList i) result)))
	   ((= i -1) result)))))

(_comment
(begin
(load "ns.lva")
(begin-test)

(check 1
       '("lava.Lava")
       (getRefListNames *rootNamespace*))
(check 1 '("lava.Lava" "lava.REPL") (getFullNameNamespaceMapKeys))

(createNamespace "foo.bar")
(check 2 '("foo.bar" "lava.Lava" "lava.REPL") (getFullNameNamespaceMapKeys))

(findOrCreateNamespace "foo.bar")
(check 3 '("foo.bar" "lava.Lava" "lava.REPL") (getFullNameNamespaceMapKeys))

(check 4
       '("foo.bar" "lava.Lava")
       (getRefListNames (findOrCreateNamespace "foo.bar")))

(findOrCreateNamespace "bar.baz")
(check 5 '("bar.baz" "foo.bar" "lava.Lava" "lava.REPL")
       (getFullNameNamespaceMapKeys))

(check 6
       '("bar.baz" "lava.Lava")
       (getRefListNames (findOrCreateNamespace "bar.baz")))

(end-test)
)
)

;-------------------------

;;;
;;; import, if a .lva file is found, will load that file.
;;; It ensures that the package statement in that file is correct.
;;;

(define *nextPackageShouldBe* '())

(define (package p c)
  (let ((PC (string-append (toString p) "." (toString c))))
    (if (not (null? *nextPackageShouldBe*))
	(if (not (equals PC *nextPackageShouldBe*))
	    (error (string-append "incorrect package: " PC
				  " should be: " *nextPackageShouldBe*))))
    (set! *currentNamespace* (findOrCreateNamespace PC))))

(_comment
(begin
(load "ns.lva")
(begin-test)

(check 1
       '("lava.REPL" "lava.Lava")
       (getRefListNames *currentNamespace*))

(package 'foo 'bar)
(check 2 '("foo.bar" "lava.Lava" "lava.REPL") (getFullNameNamespaceMapKeys))
(check 3 '("foo.bar" "lava.Lava") (getRefListNames *currentNamespace*))

(package 'foo 'bar)
(check 2 '("foo.bar" "lava.Lava" "lava.REPL") (getFullNameNamespaceMapKeys))
(check 3 '("foo.bar" "lava.Lava") (getRefListNames *currentNamespace*))

(package 'foo 'baz)
(check 2 '("foo.bar" "foo.baz" "lava.Lava" "lava.REPL")
       (getFullNameNamespaceMapKeys))
(check 2  '("foo.baz" "lava.Lava") (getRefListNames *currentNamespace*))

(package 'buz 'saw)
(check 2 '("buz.saw" "foo.bar" "foo.baz" "lava.Lava" "lava.REPL")
       (getFullNameNamespaceMapKeys))

(check 1
       '("buz.saw" "lava.Lava")
       (getRefListNames *currentNamespace*))

(package "" 'Only)
(check 1 '(".Only" "buz.saw" "foo.bar" "foo.baz" "lava.Lava" "lava.REPL")
       (getFullNameNamespaceMapKeys))
(check 1
       '(".Only" "lava.Lava")
       (getRefListNames *currentNamespace*))


(end-test)
)
)

;-------------------------

(define (alreadyImportedInPackage? name package)
  (not (eq? (member name (getRefListNames package)) false)))

(define (importX name)
  (set! name (toString name))
  (let ((loadName (replace name #\. #\/)))
    (if (alreadyImportedInPackage? name *currentNamespace*)
	(alreadyImportedInCurrentPackage name loadName)
	(importIntoCurrentPackage name loadName))))

(define (alreadyImportedInCurrentPackage name loadName)
  ;; No need to import again.  Stops infinite loading for
  ;; packages which import each other.
  ;;
  ;; REVISIT: Load .lva if touched since load time to pick up changes
  ;; (doesn't handle erasures).
  true)

(define (importIntoCurrentPackage name loadName)
  (if (not (importLavaFileIntoCurrentPackage name loadName))
      (importJavaClassIntoCurrentPackage name loadName)))

(define (importLavaFileIntoCurrentPackage name loadName)
  (let ((result false))
    (try
     (begin
       ;; The imported package needs to be imported into the current
       ;; package.
       ;;
       ;; REVISIT:
       ;;   If already loaded then 
       ;;     load if touched
       ;;     add to refList.
       ;;   This is useful so one can interactively create packages
       ;;   and have them import each other.
       ;;
       ;; If not already loaded then
       ;;   try a .lva file load first.
       (importXAux 
	name
	(lambda ()
	  ;; Depends on package procedure doing set! *currentNamespace*.
	  (require loadName)))
       (set! result true))
      (catch (java.lang.Exception ex)
	     (_print (list 'Exception ex))))))

(define (importJavaClassIntoCurrentPackage name loadName)
  ;; REVISIT: This statement will need a try/catch to reset current.
  (set! *currentNameSpace* (findOrCreateNamespace name))
  ;; REVISIT: If class and already loaded do nothing
  ;; since you can't reload classes nothing changes
  (importXAux 
   name
   (lambda ()
     (_print (string-append "need to importX " name))
     (throw 
      (new 'java.lang.Exception
	   "static loading not implemented")))))

(define (importXAux name proc)
  (let ((savedPackage #f))
    (try
     (begin
       (set! savedPackage *currentNamespace*)
       (set! *nextPackageShouldBe* name) ; ignored if class
       (proc)
       (add (getRefList savedPackage)
	    (- (size (getRefList savedPackage)) 1)
	    *currentNamespace*))
     (finally
      (set! *currentNamespace* savedPackage)
      (set! *nextPackageShouldBe* '())))))
  
(_comment
(begin
(load "ns.lva")
(begin-test)

(check 1 '("lava.Lava" "lava.REPL") (getFullNameNamespaceMapKeys))
(check 2 '("lava.REPL" "lava.Lava") (getRefListNames *currentNamespace*))

(importX 'testLava.proto.ns.one.One)
(check 3 '("lava.Lava" "lava.REPL"
	   "testLava.proto.ns.one.One" "testLava.proto.ns.two.Two")
       (getFullNameNamespaceMapKeys))
(check 4
       '("lava.REPL" "testLava.proto.ns.one.One" "lava.Lava")
       (getRefListNames *currentNamespace*))
(check 5
       '("testLava.proto.ns.one.One" "testLava.proto.ns.two.Two" "lava.Lava")
       (getRefListNames (findNamespace "testLava.proto.ns.one.One")))
(check 6
       '("testLava.proto.ns.two.Two" "lava.Lava")
       (getRefListNames (findNamespace "testLava.proto.ns.two.Two")))


(importX 'testLava.proto.ns.two.Two)
(check 6 '("lava.Lava" "lava.REPL"
	   "testLava.proto.ns.one.One" "testLava.proto.ns.two.Two")
       (getFullNameNamespaceMapKeys))
(check 7
       '("lava.REPL" "testLava.proto.ns.one.One"
	 "testLava.proto.ns.two.Two" "lava.Lava")
       (getRefListNames *currentNamespace*))

(importX 'testLava.proto.ns.two.Two)
(check 8
       '("lava.REPL" "testLava.proto.ns.one.One"
	 "testLava.proto.ns.two.Two" "lava.Lava")
       (getRefListNames *currentNamespace*))

(end-test)
)
)

;-------------------------

(define (isDotted? x)
  (if (= (indexOf x ".") -1) false true))

(define (setE! x val)
  (set! x (toString x))
  (if (isDotted? x)
      (error (string-append "setE!: no dots allowed: " x))
      (put (getMap *currentNamespace*) x val))
  val)

(define (packageAndClassOf x)
  (substring x 0 (lastIndexOf x ".")))

(define (variableOf x)
  (substring x (+ (lastIndexOf x ".") 1) (length x)))

(define (hasMultipleDots? x)
  (if (or (= (indexOf x ".") -1)
	  (= (indexOf x ".") (lastIndexOf x ".")))
      false
      true))

(define (refE x)
  (set! x (toString x))
  (if (isDotted? x)
      (refDotted (packageAndClassOf x) (variableOf x))
      (refNotDotted x *currentNamespace*)))

;;;
;;; This is the critical routine.
;;; Possibilities:
;;; 1. Only look in current namespace.
;;;    But this means you do not pick up builtin lava variables.
;;; 2. Look in current namespace.
;;;    If not found look in lava namespace.
;;;    But this means all lava imported functions must have
;;;    at least its "class" name (e.g., Aif.aif).
;;;    This most closely resembles static class methods/fields accessed.
;;;    But it is inconvenient in terms of Lisp.
;;; 3. Go through refList until found or undefined.
;;;    We choose this one.
;;;

(define (refNotDotted v namespace)
  (_print (list 'refNotDotted v))
  (let ((refList (getRefList namespace)))
    (call/cc
     (lambda (return)
       (do ((i 0 (+ i 1)))
	   ((= i (size refList)) (error (string-append "undefined: " v)))
	 (cond ((containsKey (getMap (elementAt refList i)) v)
		(_print (list 'foundIn
			      (getName (elementAt refList i))
			      (get (getMap (elementAt refList i)) v)))
		(return (get (getMap (elementAt refList i)) v)))))))))

(define (classNameOf x)
  (variableOf x))

(define (findMatch ns pc)
  (let ((refList (getRefList ns)))
    (call/cc
     (lambda (return)
       (do ((i 0 (+ i 1)))
	   ((= i (size refList)) false)
	 (if (or (equals pc              (getName (elementAt refList i)))
		 (equals pc (classNameOf (getName (elementAt refList i)))))
	     (return (elementAt refList i))))))))

(define (refDotted pc m)
  (_print (list 'refDotted pc m))
  (let* ((originalPC pc)
	 ;; Enables .foo shorthand for built-in procedures.
	 (pc (if (equals pc "") "lava.Lava" pc))
	 (ns (findMatch *currentNamespace* pc)))
    (_print (list "NS" ns m))
    (if (and (not (eq? ns false))
	     (containsKey (getMap ns) m))
	(refNotDotted m ns)
	(error (string-append "refDotted: undefined: " originalPC "." m)))))

(_comment
(begin
(load "ns.lva")
(begin-test)

(package 'lava 'Lava)
(check 0 '("lava.Lava") (getRefListNames *currentNamespace*))
(setE! 'a 'Lava-a)
(check 0 'Lava-a (refE 'a))
(check 0 'Lava-a (refE '.a))
(check 0 'Lava-a (refE 'Lava.a))
(check 0 'Lava-a (refE 'lava.Lava.a))

(package 'lava 'REPL)
(check 0 "lava.REPL" (getName *currentNamespace*))
(check 0 '("lava.REPL" "lava.Lava") (getRefListNames *currentNamespace*))
(check 0 'Lava-a (refE 'a))
(check 1 'REPL-a (setE! 'a 'REPL-a))
(check 2 'REPL-a (refE 'a))
(check 2 'Lava-a (refE '.a))
(check 2 'Lava-a (refE 'Lava.a))
(check 2 'REPL-a (refE 'REPL.a))
(check 2 'Lava-a (refE 'Lava.a))
(check 2 'REPL-a (refE 'lava.REPL.a))
(check 2 'Lava-a (refE 'lava.Lava.a))

(package 'foo.bar 'Baz)
(check 3 '("foo.bar.Baz" "lava.Lava") (getRefListNames *currentNamespace*))
(check 3 'Lava-a (refE 'a))
(setE! 'a 'Baz-a)
(check 2 'Baz-a (refE 'a))
(check 2 'Baz-a (refE 'Baz.a))
(check 2 'Lava-a (refE '.a))
(check 2 'Lava-a (refE 'Lava.a))
(check 2 'Baz-a (refE 'foo.bar.Baz.a))
(check 2 'Lava-a (refE 'lava.Lava.a))
(check 2
       "refDotted: undefined: REPL.a" 
       (try (refE 'REPL.a) 
	    (catch (java.lang.Exception e) (getMessage e))))
(check 2
       "refDotted: undefined: lava.REPL.a" 
       (try (refE 'lava.REPL.a) 
	    (catch (java.lang.Exception e) (getMessage e))))

(importX 'testLava.proto.ns.one.One)
(check 3
       '("foo.bar.Baz" "testLava.proto.ns.one.One" "lava.Lava")
       (getRefListNames *currentNamespace*))
(check 4 'Baz-a (refE 'a))
(check 4 'Lava-a (refE 'Lava.a))
(check 4 'Lava-a (refE '.a))

(package 'testLava.proto.ns.one 'One)
(check 4 "testLava.proto.ns.one.One" (getName *currentNamespace*))
(check 4 'Lava-a (refE 'a))
(check 4 'Lava-a (refE '.a))
(setE! 'a 'One-a)

(package 'foo.bar 'Baz)
(check 4 "foo.bar.Baz" (getName *currentNamespace*))
(check 3
       '("foo.bar.Baz" "testLava.proto.ns.one.One" "lava.Lava")
       (getRefListNames *currentNamespace*))
(check 0 'Baz-a (refE 'a))
(check 0 'Lava-a (refE '.a))
(check 4 'Baz-a (refE 'a))
(check 0 'One-a (refE 'One.a))
(check 0 'Lava-a (refE 'Lava.a))
(check 0 'One-a (refE 'testLava.proto.ns.one.One.a))

(package 'lava 'Lava)
(check 0 '("lava.Lava") (getRefListNames *currentNamespace*))
(check 0 'Lava-a (refE 'a))
(check 0 'Lava-a (refE '.a))
(check 0 'Lava-a (refE 'lava.Lava.a))
(check 2
       "refDotted: undefined: One.a" 
       (try (refE 'One.a) 
	    (catch (java.lang.Exception e) (getMessage e))))
(check 2
       "refDotted: undefined: testLava.proto.ns.one.One.a"
       (try (refE 'testLava.proto.ns.one.One.a) 
	    (catch (java.lang.Exception e) (getMessage e))))

(package "" 'Only)
(setE! 'a 'Only-a)
(check 0 'Only-a (refE 'a))
(check 0 'Only-a (refE 'Only.a))
;(check 0 'Lava-a (refE '.a))

(end-test)
)
)

;-------------------------

(define (newE x . args)
  (let ((xAsString (toString x)))
    (if (isDotted? xAsString)
	(apply new (cons x args))
	(newNotDotted xAsString args))))

(define (newNotDotted x args)
  (let ((ns (findMatch *currentNamespace* x)))
    (if (not (eq? ns false))
	(apply new (cons (string->symbol (getName ns)) args))
	(else (error (string-append "Undefined: " x))))))

(_comment
(begin
(load "ns.lva")
(begin-test)

(newE 'java.util.Hashtable)
(importX 'java.util.Hashtable)
(newE 'Hashtable)

(end-test)
)
)

;;; End of file.
