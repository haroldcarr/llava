;;;;
;;;; Created       : 2000 Oct 21 (Sat) 10:46:48 by Harold Carr.
;;;; Last Modified : 2004 Dec 22 (Wed) 10:37:38 by Harold Carr.
;;;;

;; Think about:
;; * From any package you must import to enable BOTH short and long references.
;;   In other words, only can ref imported things.
;; * Have import precompute as much reflection as possible on all methods
;;   on each class to avoid full DI.
;; * try/catch should know about current imports (like new does - or rather will)
;; * Same goes for instanceof.  What else?
;; * Use classpath to search for .lva/.class files.
;;   For each path first look for .lva then .class if not found
;;   then next path if not found.

(require 'test/test)

(define *topLevelNamespace* null)

(define *fullNameNamespaceMap*
  (new 'java.util.Hashtable))

(define (createNamespace x)
  (let ((ns (new 'testLava.Namespace x *topLevelNamespace*)))
    (put *fullNameNamespaceMap* x ns)
    ns))

;; N.B.: Each namespace always contains the topLevelNamespace
;; at the end of its refList.  During initialization we need to
;; explicitly remove this reference - both because it doesn't
;; exist so it is null - and if it did exist would cause a circular
;; lookup.
;; REVISIT: access to lava.Lava.foo via .foo
(set! *topLevelNamespace* (createNamespace "lava.Lava"))
(remove (getRefList *topLevelNamespace*) 1)

(define *replNamespace* (createNamespace "lava.REPL"))
(define *currentNamespace* *replNamespace*)

(define (findNamespace x)
  (get *fullNameNamespaceMap* x))

(define (findOrCreateNamespace x)
  (let ((ns (findNamespace x)))
    (if (null? ns)
        (createNamespace x)
	ns)))

(define (getRefListNames ns)
  (let ((refList (getRefList ns)))
    (do ((result '()    
		 (cons (getName (elementAt refList i)) result))
	 (i      (- (size refList) 1) 
		 (- i 1)))
	((= i -1) result))))

(.comment
(begin
(load "ns.lva")
(begin-test)

(check 1
       '("lava.Lava")
       (getRefListNames *topLevelNamespace*))
*fullNameNamespaceMap*
(check 2 2 (size *fullNameNamespaceMap*))
(createNamespace "foo.bar")
*fullNameNamespaceMap*
(check 3 3 (size *fullNameNamespaceMap*))
(findOrCreateNamespace "foo.bar")
*fullNameNamespaceMap*
(check 4 3 (size *fullNameNamespaceMap*))
(check 5
       '("foo.bar" "lava.Lava")
       (getRefListNames (findOrCreateNamespace "foo.bar")))
(findOrCreateNamespace "bar.baz")
*fullNameNamespaceMap*
(check 4 4 (size *fullNameNamespaceMap*))
(check 6
       '("bar.baz" "lava.Lava")
       (getRefListNames (findOrCreateNamespace "bar.baz")))
(end-test)
)
)

;-------------------------

(define *nextPackageShouldBe* '())

(define (package p c)
  (let ((PC (string-append (toString p) "." (toString c))))
    (if (not (null? *nextPackageShouldBe*))
	(if (not (equals PC *nextPackageShouldBe*))
	    (error (string-append "incorrect package: "
				  PC
				  " should be: "
				  *nextPackageShouldBe*))))
    (set! *currentNamespace* (findOrCreateNamespace PC))))

(.comment
(begin
(load "ns.lva")
(begin-test)
(check 1
       '("lava.REPL" "lava.Lava")
       (getRefListNames *currentNamespace*))
*fullNameNamespaceMap*
(check 2 2 (size *fullNameNamespaceMap*))
(package 'foo 'bar)
*fullNameNamespaceMap*
(check 3 3 (size *fullNameNamespaceMap*))
(check 4 
       '("foo.bar" "lava.Lava")
       (getRefListNames *currentNamespace*))
(package 'foo 'bar)
*fullNameNamespaceMap*
(check 3 3 (size *fullNameNamespaceMap*))
(check 4 
       '("foo.bar" "lava.Lava")
       (getRefListNames *currentNamespace*))
(package 'foo 'baz)
*fullNameNamespaceMap*
(check 3 4 (size *fullNameNamespaceMap*))
(check 2
       '("foo.baz" "lava.Lava")
       (getRefListNames *currentNamespace*))
(package 'buz 'saw)
*fullNameNamespaceMap*
(check 3 5 (size *fullNameNamespaceMap*))
(check 1
       '("buz.saw" "lava.Lava")
       (getRefListNames *currentNamespace*))
(package "" 'Only)
(check 1
       '(".Only" "lava.Lava")
       (getRefListNames *currentNamespace*))

(end-test)
)
)

;-------------------------

(define (importX name)
  (set! name (toString name))
  (let ((loadName (replace name #\. #\/)))
    (if (not (eq? (member name (getRefListNames *currentNamespace*))
		  false))
	true ;; but load it if touched since load time to pick up changes
	     ;; but that doesn't handle erasures.
	(try
	 (begin
	   ;; Try a file load first.
	   (importXAux 
	    name
	    (lambda ()
	      ;; Depends on package procedure doing set! *currentNamespace*.
	      (require loadName)))) 
	 (catch (java.lang.Exception ex)
		;; If that does not work try to "load" the class.
		(.print (list 'Exception ex))
		;; This statement will need a try/catch to reset current.
		(set! *currentNameSpace* (findOrCreateNamespace name))
		;; If class and already loaded do nothing
		;; since you can't reload classes nothing changes
		(importXAux 
		 name
		 (lambda ()
		   (.print "need to importX")
		   (throw 
		    (new 'java.lang.Exception
			 "static loading not implemented")))))))))

(define (importXAux name proc)
  (let ((savedPackage #f))
    (try
     (begin
       (set! savedPackage *currentNamespace*)
       (set! *nextPackageShouldBe* name) ; ignored if class
       (proc)
       (add (getRefList savedPackage)
	    (- (size (getRefList savedPackage)) 1)
	    *currentNamespace*))
     (finally
      (set! *currentNamespace* savedPackage)
      (set! *nextPackageShouldBe* '())))))
  
(.comment
(begin
(load "ns.lva")
(begin-test)
*fullNameNamespaceMap*
(check 1 2 (size *fullNameNamespaceMap*))
(check 2
       '("lava.REPL" "lava.Lava")
       (getRefListNames *currentNamespace*))
(importX 'testLava.ns.one.One)
*fullNameNamespaceMap*
(check 3 4 (size *fullNameNamespaceMap*))
(check 4
       '("lava.REPL" "testLava.ns.one.One" "lava.Lava")
       (getRefListNames *currentNamespace*))
(check 5
       '("testLava.ns.one.One" "testLava.ns.two.Two" "lava.Lava")
       (getRefListNames (findNamespace "testLava.ns.one.One")))
(check 6
       '("testLava.ns.two.Two" "lava.Lava")
       (getRefListNames (findNamespace "testLava.ns.two.Two")))

(importX 'testLava.ns.two.Two)
(check 7
       '("lava.REPL" "testLava.ns.one.One" "testLava.ns.two.Two" "lava.Lava")
       (getRefListNames *currentNamespace*))
(importX 'testLava.ns.two.Two)
(check 8
       '("lava.REPL" "testLava.ns.one.One" "testLava.ns.two.Two" "lava.Lava")
       (getRefListNames *currentNamespace*))
(end-test)
)
)

;-------------------------

(define (isDotted? x)
  (if (= (indexOf x ".") -1)
      false
      true))

(define (setE! x val)
  (set! x (toString x))
  (if (isDotted? x)
      (error (string-append "setE!: no dots allowed: " x))
      (put (getMap *currentNamespace*) x val))
  val)

(define (packageAndClassOf x)
  (substring x 0 (lastIndexOf x ".")))

(define (variableOf x)
  (substring x (+ (lastIndexOf x ".") 1) (length x)))

(define (hasMultipleDots? x)
  (if (or (= (indexOf x ".") -1)
	  (= (indexOf x ".") (lastIndexOf x ".")))
      false
      true))

(define (refE x)
  (set! x (toString x))
  (if (isDotted? x)
      (refDotted (packageAndClassOf x) (variableOf x))
      (refNotDotted x)))

;;;
;;; This is the critical routine.
;;; Possibilities:
;;; 1. Only look in current namespace.
;;;    But this means you do not pick up builtin lava variables.
;;; 2. Look in current namespace.
;;;    If not found look in lava namespace.
;;;    But this means all lava imported functions must have
;;;    at least its "class" name (e.g., Aif.aif).
;;;    This most closely resembles static class methods/fields accessed.
;;;    But it is inconvenient in terms of Lisp.
;;; 3. Go through refList until found or undefined.
;;;    

(define (refNotDotted x)
  (.print (list 'refNotDotted x))
  (cond (;; #1 and 2
	 (containsKey (getMap *currentNamespace*) x)
	 (get (getMap *currentNamespace*) x))
	;;(;; #2
	;; (containsKey (getMap *topLevelNamespace*) x)
	;; (get (getMap *topLevelNamespace*) x))
	(;; #3
	 (let ((refList (getRefList *currentNamespace*)))
	   (call/cc
	    (lambda (return)
	      (do ((i 0 (+ i 1)))
		  ((= i (size refList)) false)
		(cond ((containsKey (getMap (elementAt refList i)) x)
		       (.print (list 'foundIn
				     (getName (elementAt refList i))
				     (get (getMap (elementAt refList i)) x)))
		       (return (get (getMap (elementAt refList i)) x)))))))))
	(else
	 (error (string-append "undefined: " x)))))

(define (classNameOf x)
  (variableOf x))

(define (endsWithMatch ns x)
  (let ((refList (getRefList ns)))
    (call/cc
     (lambda (return)
       (do ((i (- (size refList) 1) (- i 1)))
	   ((= i -1) false)
	 (if (equals x (classNameOf (getName (elementAt refList i))))
	     (return (elementAt refList i))))))))

(define (refDotted pc m)
  (.print (list 'refDotted pc m))
  ;; REVISIT - only allow abbreviated or full refs to names in refList
  ;; instead of global as is done here.
  (cond ((containsKey *fullNameNamespaceMap* pc)
	 (lookup (get *fullNameNamespaceMap* pc) m))
	((hasMultipleDots? pc) (error (string-append "undefined: " m)))
	((let ((ns (endsWithMatch *currentNamespace* pc)))
	   (.print (list "NS" ns m))
	   (if (and (not (eq? ns false))
		    (containsKey (getMap ns) m))
	       (lookup ns m)
	       (error (string-append "refDotted: undefined: " 
				     pc "." m)))))))

(define (lookup namespace x)
  (let ((savedNamespace *currentNamespace*))
    (try 
     (begin
       (set! *currentNamespace* namespace)
       (refNotDotted x))
     (finally
      (set! *currentNamespace* savedNamespace)))))


(.comment
(begin
(load "ns.lva")
(begin-test)
(check 1 'REPL-a (setE! 'a 'REPL-a))
(check 2 'REPL-a (refE 'a))
(check 3
       '("lava.REPL" "lava.Lava")
       (getRefListNames *currentNamespace*))
(package 'foo.bar 'Baz)
(check 3
       '("foo.bar.Baz" "lava.Lava")
       (getRefListNames *currentNamespace*))
(setE! 'a 'Baz-a)
(check 2 'Baz-a (refE 'a))
(check 2 'Baz-a (refE 'foo.bar.Baz.a))
(check 2
       "refDotted: undefined: REPL.a" 
       (try (refE 'REPL.a) (catch (java.lang.Exception e) (getMessage e))))
(importX 'testLava.ns.one.One)
(check 3
       '("foo.bar.Baz" "testLava.ns.one.One" "lava.Lava")
       (getRefListNames *currentNamespace*))
(package 'testLava.ns.one 'One)
(check 4 "testLava.ns.one.One" (getName *currentNamespace*))
(setE! 'a 'One-a)
(package 'foo.bar 'Baz)
(check 4 "foo.bar.Baz" (getName *currentNamespace*))
(check 0 'One-a (refE 'One.a))

;; *****
(set! *currentNamespace* (findNamespace "lava.Lava"))
(setE! 'a 'Lava-a)
(check 0 'Lava-a (refE 'a))
(check 0 
       '"refDotted: undefined: .a"
       (try (refE '.a) (catch (java.lang.Exception e) (getMessage e))))
(check 0 'Lava-a (refE 'lava.Lava.a))
(package 'foo.bar 'Baz)
(check 3
       '("foo.bar.Baz" "testLava.ns.one.One" "lava.Lava")
       (getRefListNames *currentNamespace*))
(check 0 'Baz-a (refE 'a))
(check 0 
       '"refDotted: undefined: .a"
       (try (refE '.a) (catch (java.lang.Exception e) (getMessage e))))
(check 0 'One-a (refE 'One.a))
(check 0 'One-a (refE 'testLava.ns.one.One.a))
(check 0 'REPL-a (refE 'lava.REPL.a))
(package "" 'Only)
(setE! 'a 'Only-a)
(check 0 'Only-a (refE 'a))
(check 0 'Only-a (refE 'Only.a))
(check 0 'Lava-a (refE '.a))
(end-test)
)
)

;-------------------------

(define (newE x . args)
  (let ((xAsString (toString x)))
    (if (isDotted? xAsString)
	(apply new (cons x args))
	(newNotDotted xAsString args))))

(define (newNotDotted x args)
  (let ((ns (endsWithMatch *currentNamespace* x)))
    (if (not (eq? ns false))
	(apply new (cons (string->symbol (getName ns)) args))
	(else (error (string-append "Undefined: " x))))))

(.comment
(begin
(begin-test)
(load "ns.lva")
(newE 'java.util.Hashtable)
(importX 'java.util.Hashtable)
(newE 'Hashtable)
(end-test)
)
)

;;; End of file.
